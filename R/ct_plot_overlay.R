#' Overlay multiple data sets onto a single concentration-time graph
#'
#' \code{ct_plot_overlay} is meant to be used in conjunction with
#' \code{\link{extractConcTime_mult}} to create single graphs with overlaid
#' concentration-time data of multiple tissues, compounds, or Simcyp Simulator
#' output files for easy comparisons. \emph{Note:} There are some nuances to
#' overlaying observed data. Please see the "Details" section at the bottom of
#' this help file. Also, this hasn't really been developed or tested with
#' enzyme-abundance data or ADAM data yet.
#'
#' \strong{Notes on including observed data:} We recently added the option of
#' including observed data and are in the process of testing this. To include
#' observed data, you have two options: \enumerate{
#'
#' \item{Use the Simulator Excel PE data entry template to save your observed
#' data. Then, when you run \code{\link{extractConcTime_mult}}, supply the names
#' of those Excel files to the observed data  function argument. This is the
#' BEST option because it contains the most information about the observed
#' data.}
#'
#' \item{Include observed data in your simulation files. Those data will be
#' automatically extracted when you run \code{\link{extractConcTime_mult}} if
#' "obs_data_files" is left as the default NA. The drawback to this approach is
#' that it's not clear whether there was an inhibitor present, for example, or
#' which compound the data describe.} }
#'
#' The \code{ct_plot_overlay} function will automatically figure out which
#' observed data should be compared with which simulated compound IDs, tissues,
#' etc. However, because the function doesn't know which simulator \emph{file}
#' goes with which observed data, it will assume that \emph{all} the observed
#' data are appropriate to compare to \emph{all} the files included in
#' \code{ct_dataframe} by default. If that's not the case, after you use
#' \code{\link{extractConcTime_mult}} to extract your data, you can indicate
#' which simulator output file goes with which observed file by setting the
#' simulator output file in the column "File". This admittedly requires a bit of
#' R knowledge, so please ask a member of the R Working Group for help if you're
#' not clear on how to do this. Be warned, though, that if you assign "File" for
#' some observed data but not all, only the observed data with an assignment for
#' "File" will show up on the graph.
#'
#' One other note: The observed data files from the PE data-entry template don't
#' include the \emph{name} of the compound you're simulating (column:
#' "Compound"). They do include whether it was a substrate, metabolite, or
#' inhibitor (column: CompoundID), but not the compound's actual name. For that
#' reason, try coloring or facetting your data by CompoundID rather than by
#' Compound if you have observed data. Similarly, if you have an inhibitor and
#' you have observed data, the inhibitor will be listed as the generic
#' "inhibitor" here rather than, e.g., "ketoconazole" because the observed data
#' file doesn't indicate that.
#'
#'
#'
#' @param ct_dataframe the input concentration-time data generated by running
#'   the function \code{\link{extractConcTime_mult}} or
#'   \code{\link{extractConcTime}}. Not quoted.
#' @param mean_type plot "arithmetic" (default) or "geometric" mean
#'   concentrations or "median" concentrations as the main (thickest or only)
#'   line for each data set. If this aggregate measure is not available in the
#'   simulator output, you'll receive a warning message and we'll plot one that
#'   \emph{is} available.
#' @param figure_type the type of figure to plot. \describe{
#'
#'   \item{"means only"}{show only the mean, geometric mean, or median (whatever
#'   you chose for "mean_type"). This is the default.}
#'
#'   \item{"percentile ribbon"}{show an opaque line for the mean data and
#'   transparent shading for the 5th to 95th percentiles. Note: You may
#'   sometimes see some artifacts -- especially for semi-log plots -- where the
#'   ribbon gets partly cut off. For arcane reasons we don't want to bore you
#'   with here, we can't easily prevent this. To fix this, increase your y axis
#'   limits for the semi-log plot.}}
#' @param linear_or_log the type of graph to be returned. Options: \describe{
#'   \item{"semi-log"}{y axis is log transformed; this is the default}
#'
#'   \item{"linear"}{no axis transformation}
#'
#'   \item{"both vertical"}{both the linear and the semi-log graphs will be
#'   returned, and graphs are stacked vertically}
#'
#'   \item{"both horizontal"}{both the linear and the semi-log graphs will be
#'   returned, and graphs are stacked horizontally}}
#' @param linetype_column the column in \code{ct_dataframe} that should be used
#'   for determining the line types. Default is to use the column Inhibitor and
#'   to have a solid line for no inhibitor present and a dashed line when an
#'   inhibitor is present.
#' @param linetypes the linetypes to use. Default is "solid" for all lines, but,
#'   if you have an effector present and would like to match the Consultancy
#'   Template graphs, set this to \code{linetypes = c("solid", "dashed")}. The
#'   tricky part is that you'll need one linetype for each possible value in the
#'   column you specified for \code{linetype_column}. Check what the unique
#'   values are in that column if you get a graph you didn't expect as far as
#'   line types go.
#' @param colorBy_column the column in \code{ct_dataframe} that should be used
#'   for determining which color lines and/or points will be. Default is to use
#'   the column File. This should be unquoted, e.g., \code{colorBy_column =
#'   Tissue}.
#' @param color_labels optionally specify a character vector for how you'd like
#'   the labels for whatever you choose for \code{colorBy_column} to show up in
#'   the legend. For example, use \code{c("file 1.xlsx" = "fa 0.5", "file
#'   2.xlsx" = "fa 0.2")} to indicate that "file 1.xlsx" is for an fa of 0.5 and
#'   "file 2.xlsx" is for an fa of 0.2. The order in the legend will match the
#'   order designated here.
#' @param facet1_column optionally break up the graph into small multiples; this
#'   specifies the first of up to two columns to break up the data by, and the
#'   designated column name should be unquoted, e.g., \code{facet1_column =
#'   Tissue}. If \code{floating_facet_scale} is FALSE, then \code{facet1_column}
#'   will designate the rows of the output graphs.
#' @param facet2_column optionally break up the graph into small multiples; this
#'   specifies the second of up to two columns to break up the data by, and the
#'   designated column name should be unquoted, e.g., \code{facet2_column =
#'   CompoundID}. If \code{floating_facet_scale} is FALSE, then
#'   \code{facet2_column} will designate the columns of the output graphs.
#' @param floating_facet_scale TRUE or FALSE (default) for whether to allow the
#'   axes for each facet of a multi-facetted graph to scale freely to best fit
#'   whatever data are present. Default is FALSE, which means that all data will
#'   be on the same scale for easy comparison. However, this could mean that
#'   some graphs have lines that are hard to see, so you can set this to TRUE to
#'   allow the axes to shrink or expand according to what data are present for
#'   that facet. Floating axes comes with a trade-off for the looks of the
#'   graphs, though: Setting this to TRUE does mean that your x axis won't
#'   automatically have pretty breaks that are sensible for times in hours.
#' @param time_range time range to display. Options: \describe{
#'
#'   \item{NA}{entire time range of data; default}
#'
#'   \item{a start time and end time in hours}{only data in that time range,
#'   e.g. \code{c(24, 48)}. Note that there are no quotes around numeric data.}
#'
#'   \item{"first dose"}{only the time range of the first dose}
#'
#'   \item{"last dose"}{only the time range of the last dose}
#'
#'   \item{"penultimate dose"}{only the time range of the 2nd-to-last dose,
#'   which can be useful for BID data where the end of the simulation extended
#'   past the dosing interval or data when the substrate was dosed BID and the
#'   effector was dosed QD}
#'
#'   \item{a specific dose number with "dose" or "doses" as the prefix}{the time
#'   range encompassing the requested doses, e.g., \code{time_range = "dose 3"}
#'   for the 3rd dose or \code{time_range = "doses 1 to 4"} for doses 1 to 4}
#'
#'   \item{"all obs" or "all observed" if you feel like spelling it out}{Time
#'   range will be limited to only times when observed data are present.}
#'
#'   \item{"last dose to last observed" or "last obs" for short}{Time range will
#'   be limited to the start of the last dose until the last observed data
#'   point.} }
#'
#'
#' @param pad_x_axis optionally add a smidge of padding to the x axis (default
#'   is TRUE, which includes some generally reasonable padding). If changed to
#'   FALSE, the y axis will be placed right at the beginning of your time range
#'   and all data will end \emph{exactly} at the end of the time range
#'   specified. If you want a \emph{specific} amount of x-axis padding, set this
#'   to a number; the default is \code{c(0.02, 0.04)}, which adds 2\% more space
#'   to the left side and 4\% more space to the right side of the x axis. If you
#'   only specify one number, padding is added to the left side.
#' @param pad_y_axis optionally add a smidge of padding to the y axis (default
#'   is TRUE, which includes some generally reasonable padding). As with
#'   \code{pad_x_axis}, if changed to FALSE, the x axis will be placed right at
#'   the bottom of your data, possible cutting a point in half. If you want a
#'   \emph{specific} amount of y-axis padding, set this to a number; the default
#'   is \code{c(0.02, 0)}, which adds 2\% more space to the bottom and nothing
#'   to the top of the y axis. If you only specify one number, padding is added
#'   to the bottom.
#' @param x_axis_interval set the x-axis major tick-mark interval. Acceptable
#'   input: any number or leave as NA to accept default values, which are
#'   generally reasonable guesses as to aesthetically pleasing and PK-relevant
#'   intervals.
#' @param color_set the set of colors to use. Options: \describe{
#'
#'   \item{"default"}{a set of colors from Cynthia Brewer et al. from Penn State
#'   that are friendly to those with red-green colorblindness. The first three
#'   colors are green, orange, and purple. This can also be referred to as
#'   "Brewer set 2". If there are only two unique values in the colorBy_column,
#'   then Brewer set 1 will be used since red and blue are still easily
#'   distinguishable but also more aesthetically pleasing than green and
#'   orange.}
#'
#'   \item{"Brewer set 1"}{colors selected from the Brewer palette "set 1". The
#'   first three colors are red, blue, and green.}
#'
#'   \item{"ggplot2 default"}{the default set of colors used in ggplot2 graphs
#'   (ggplot2 is an R package for graphing.)}
#'
#'   \item{"rainbow"}{colors selected from a rainbow palette. The default
#'   palette is limited to something like 6 colors, so if you have more than
#'   that, that's when this palette is most useful. It's \emph{not} very useful
#'   when you only need a couple of colors.}
#'
#'   \item{"blue-green"}{a set of blues and greens}
#'
#'   \item{"Tableau"}{uses the standard Tableau palette; requires the "ggthemes"
#'   package}}
#' @param obs_transparency Optionally make the observed data points
#'   semi-transparent, which can be helpful when there are numerous
#'   observations. Acceptable values are 0 (completely transparent) to 1
#'   (completely opaque).
#' @param save_graph optionally save the output graph by supplying a file name
#'   in quotes here, e.g., "My conc time graph.png". If you do not designate a
#'   file extension, it will be saved as a png file, but if you specify a
#'   different file extension, it will be saved as that file format. Acceptable
#'   extensions are "eps", "ps", "jpeg", "jpg", "tiff", "png", "bmp", or "svg".
#'   Leaving this as NA means the file will not be automatically saved to disk.
#' @param fig_height figure height in inches; default is 6
#' @param fig_width figure width in inches; default is 5
#'
#' @param y_axis_limits_lin Optionally set the Y axis limits for the linear
#'   plot, e.g., \code{c(10, 1000)}. If left as NA, the Y axis limits for the
#'   linear plot will be automatically selected. This only applies when you have
#'   requested a linear plot with \code{linear_or_log}.
#' @param graph_labels TRUE or FALSE for whether to include labels (A, B, C,
#'   etc.) for each of the small graphs. (Not applicable if only outputting
#'   linear or only semi-log graphs.)
#' @param y_axis_limits_log Optionally set the Y axis limits for the semi-log
#'   plot, e.g., \code{c(10, 1000)}. Values will be rounded down and up,
#'   respectively, to the nearest order of magnitude. If left as NA, the Y axis
#'   limits for the semi-log plot will be automatically selected. This only
#'   applies when you have requested a semi-log plot with \code{linear_or_log}.
#' @param legend_position Specify where you want the legend to be. Options are
#'   "left", "right" (default in most scenarios), "bottom", "top", or "none" if
#'   you don't want one at all.
#' @param legend_label_color optionally indicate on the legend something
#'   explanatory about what the colors represent. For example, if
#'   \code{colorBy_column = File} and \code{legend_label_color = "Simulations
#'   with various fa values"}, that will make the label above the file names in
#'   the legend more explanatory than just "File". The default is to use
#'   whatever the column name is for \code{colorBy_column}. If you don't want a
#'   label for this legend item, set this to "none".
#' @param legend_label_linetype optionally indicate on the legend something
#'   explanatory about what the line types represent. For example, if
#'   \code{linetype_column = Inhibitor} and \code{legend_label_linetype =
#'   "Inhibitor present"}, that will make the label in the legend above, e.g.,
#'   "none", and whatever effector was present more explanatory than just
#'   "Inhibitor". The default is to use whatever the column name is for
#'   \code{linetype_column}. If you don't want a label for this legend item, set
#'   this to "none".
#' @param facet_spacing Optionally set the spacing between facets. If left as
#'   NA, a best-guess as to a reasonable amount of space will be used. Units are
#'   "lines", so try, e.g. \code{facet_spacing = 2}. (Reminder: Numeric data
#'   should not be in quotes.)
#'
#'
#' @return
#' @export
#'
#' @examples
#' data(MDZct)
#' ct_plot_overlay(ct_dataframe = MDZct, colorBy_column = File)
#'
#' # Setting the legend labels for color to be more interpretable. Note
#' # that the order matches the order listed here, not the alphabetical
#' # order of the files.
#' ct_plot_overlay(ct_dataframe = MDZct, colorBy_column = File,
#'                 color_labels = c("mdz-5mg-sd-fa1.xlsx" = "fa 1",
#'                                  "mdz-5mg-sd-fa0_8.xlsx" = "fa 0.8",
#'                                  "mdz-5mg-sd-fa0_6.xlsx" = "fa 0.6",
#'                                  "mdz-5mg-sd-fa0_4.xlsx" = "fa 0.4"))
#'
#' # An example of how you might set the column "File" for a specific
#' # observed data file:
#' MyData <- MyData %>%
#'    mutate(File = case_when(ObsFile == "ObservedData1.xlsx" ~ "SimFileA.xlsx",
#'                            ObsFile == "ObservedData2.xlsx" ~ "SimFileB.xlsx"))
#'
#'
#' 
ct_plot_overlay <- function(ct_dataframe,
                            mean_type = "arithmetic",
                            figure_type = "means only", 
                            linear_or_log = "semi-log",
                            colorBy_column = File,
                            color_labels = NA, 
                            color_set = "default",
                            obs_transparency = NA, 
                            linetype_column = Inhibitor, 
                            linetypes = "solid",
                            facet1_column,
                            facet2_column, 
                            floating_facet_scale = FALSE,
                            facet_spacing = NA,
                            time_range = NA, 
                            x_axis_interval = NA,
                            pad_x_axis = TRUE,
                            pad_y_axis = TRUE,
                            y_axis_limits_lin = NA,
                            y_axis_limits_log = NA, 
                            graph_labels = TRUE,
                            legend_position = NA,
                            legend_label_color = NA,
                            legend_label_linetype = NA,
                            save_graph = NA,
                            fig_height = 6,
                            fig_width = 5){
    
    # Setting things up for some nonstandard evaluation -------------------------
    
    facet1_column <- rlang::enquo(facet1_column)
    facet2_column <- rlang::enquo(facet2_column)
    colorBy_column <- rlang::enquo(colorBy_column)
    linetype_column <- rlang::enquo(linetype_column)
    
    # I *would* be doing this whole function with nonstandard evaluation except
    # that I CANNOT figure out how to use NSE to redefine a user-supplied
    # column, so I'm going to have to rename all of them. This makes the rest of
    # checking and developing this function easier, too, though.
    
    # ct_dataframe <- ct_dataframe %>%
    #     mutate(colorBy_column = ifelse(as_label(colorBy_column) == "<empty>", NA, {{colorBy_column}}),
    #            FC1 = ifelse(as_label(facet1_column) == "<empty>", NA, {{facet1_column}}),
    #            FC2 = ifelse(as_label(facet2_column) == "<empty>", NA, {{facet2_column}}))
    
    ### NOT THE ABOVE. This causes everything to be the same value. Below code works. 
    
    if(as_label(colorBy_column) != "<empty>"){
        ct_dataframe <- ct_dataframe %>%
            mutate(colorBy_column = {{colorBy_column}})
        
        if(class(ct_dataframe$colorBy_column) == "numeric"){
            Levels <- sort(unique(ct_dataframe$colorBy_column))
            ct_dataframe <- ct_dataframe %>% 
                mutate(colorBy_column = factor(colorBy_column, levels = Levels))
        }
    }
    
    if(as_label(linetype_column) != "<empty>"){
        ct_dataframe <- ct_dataframe %>%
            mutate(linetype_column = {{linetype_column}})
        
        if(class(ct_dataframe$linetype_column) == "numeric"){
            Levels <- sort(unique(ct_dataframe$linetype_column))
            ct_dataframe <- ct_dataframe %>% 
                mutate(linetype_column = factor(linetype_column, levels = Levels))
        }
    }
    
    if(as_label(facet1_column) != "<empty>"){
        ct_dataframe <- ct_dataframe %>%
            mutate(FC1 = {{facet1_column}})
    }
    
    if(as_label(facet2_column) != "<empty>"){
        ct_dataframe <- ct_dataframe %>%
            mutate(FC2 = {{facet2_column}})
    }
    
    # error catching -------------------------------------------------------
    # Checking for ADAM model data b/c those don't work well here. 
    if(any(unique(ct_dataframe$Tissue) %in% 
           c("stomach", "duodenum", "jejunum I", "jejunum II", 
             "ileum I", "ileum II", "ileum III", "ileum IV",
             "colon", "faeces", "gut tissue"))){
        if(all(unique(ct_dataframe$Tissue) %in% 
               c("stomach", "duodenum", "jejunum I", "jejunum II", 
                 "ileum I", "ileum II", "ileum III", "ileum IV",
                 "colon", "faeces", "gut tissue"))){
            stop("We're sorry, but this function has not been set up to deal with ADAM-model tissue concentrations since the units can be so different from other concentration-time data. Since all of the supplied data are ADAM model concentrations, no graph can be made.",
                 call. = FALSE)
        } else {
            warning("Some of the data you supplied are ADAM-model tissue concentrations, but this function has not been set up to deal with that since the units can be so different from other concentration-time data. The ADAM-model data will be omitted from the graph.",
                    call. = FALSE)
        }
    }
    
    ct_dataframe <- ct_dataframe %>% 
        filter(!Tissue %in% c("stomach", "duodenum", "jejunum I", "jejunum II", 
                              "ileum I", "ileum II", "ileum III", "ileum IV",
                              "colon", "faeces", "gut tissue"))
    
    if(length(time_range) == 1 && complete.cases(time_range[1]) &&
       !str_detect(time_range, "dose|last obs|all obs")){
        if(complete.cases(time_range)){
            warning("You have specified only 1 value for the time range and you don't appear to be specifying a time range by dose number, so we're not sure whether you want that to be the start or the end time. The full time range of all simulations will be used.",
                    call. = FALSE)
            time_range <- NA
        }
    } else {
        if(length(time_range) > 2){
            warning("You have specified more than 2 values for the time range, which only calls for a start time and an end time. Only the 1st two values you listed will be used for the time range.",
                    call. = FALSE)
            time_range <- time_range[1:2]
        } 
        
        if(class(time_range) != "numeric" && complete.cases(time_range[1]) &&
           !str_detect(time_range, "dose|last obs|all obs")){
            warning("You don't appear to be specifying a time range by dose number, and you have not specified numeric data for the start and end of your time range, which is the input required for this function if you're not supplying a dose number. The full time range will be used.",
                    call. = FALSE)
            time_range <- NA
        }
    }
    
    MyMeanType <- ct_dataframe %>%
        filter(Trial %in% c("geomean", "mean", "median")) %>% 
        pull(Trial) %>% unique() %>% 
        factor(levels = c("mean", "geomean", "median")) %>% 
        sort()
    
    if(switch(mean_type, "arithmetic" = "mean", "geometric" = "geomean",
              "median" = "median") %in% ct_dataframe$Trial == FALSE){
        
        warning(paste0("You requested the ", 
                       switch(mean_type, "arithmetic" = "arithmetic means",
                              "geometric" = "geometric means", 
                              "median" = "medians"), 
                       ", but those are not included in your data. Instead, the ",
                       ifelse(MyMeanType[1] == "mean", 
                              "arithmetic mean", MyMeanType[1]),
                       "s will be used."),
                call. = FALSE)
        MyMeanType <- MyMeanType[1] %>% as.character()
        
    } else {
        
        MyMeanType <- switch(mean_type, "arithmetic" = "mean",
                             "geometric" = "geomean",
                             "median" = "median")
        
    }
    
    if("subsection_ADAM" %in% names(ct_dataframe)){
        ct_dataframe <- ct_dataframe %>% 
            # At least at this point, I can't see this function working well with
            # ADAM model data b/c the y axis units differ. Removing all ADAM model
            # data.
            filter(is.na(subsection_ADAM))
    }
    
    ct_dataframe <- ct_dataframe %>%
        # If it's dose number 0, remove those rows so that we'll show only the
        # parts we want when facetting and user wants scales to float freely.
        filter(DoseNum != 0 | Simulated == FALSE) %>% 
        mutate(Group = paste(File, Trial, Tissue, CompoundID, Compound, Inhibitor),
               CompoundID = factor(CompoundID,
                                   levels = c("substrate", "primary metabolite 1",
                                              "primary metabolite 2", "secondary metabolite",
                                              "inhibitor 1", "inhibitor 1 metabolite", 
                                              "inhibitor 2"))) 
    
    sim_dataframe <- ct_dataframe %>%
        filter(Simulated == TRUE &
                   Trial %in% 
                   switch(figure_type, 
                          "means only" = MyMeanType, 
                          "percentile ribbon" = c(MyMeanType, "per5", "per95"),
                          "ribbon" = c(MyMeanType, "per5", "per95")))
    
    obs_data <- ct_dataframe %>% filter(Simulated == FALSE) %>% 
        mutate(Trial = {MyMeanType})
    
    # Making obs data black if File was originally NA for all
    if(nrow(obs_data) > 0 && "File" == as_label(colorBy_column) & all(is.na(obs_data$File))){
        InternalAssignFile <- TRUE
    } else {
        InternalAssignFile <- FALSE
    }
    
    # Setting this up so that observed data will be shown for all Files
    if(nrow(obs_data) > 0 && "File" %in% c(as_label(colorBy_column), as_label(facet1_column), 
                                           as_label(facet2_column)) &&
       all(is.na(obs_data$File))){
        
        ToAdd <- expand_grid(ObsFile = unique(obs_data$ObsFile), 
                             File = unique(sim_dataframe$File))
        obs_data <- obs_data %>% select(-File) %>% 
            left_join(ToAdd)
    } 
    
    # Dealing with the fact that the observed data will list the inhibitor as
    # "inhibitor" unless the user changes it, but that sim data will list its
    # name
    if(nrow(obs_data) > 0 & any(obs_data$Inhibitor == "inhibitor")){
        ct_dataframe <- ct_dataframe %>% 
            mutate(Inhibitor = ifelse(Inhibitor == "none", Inhibitor, "inhibitor"))
    }
    
    # Now that all columns in both sim and obs data are filled in whenever they
    # need to be, setting factors for color_labels. 
    if(complete.cases(color_labels[1])){
        simcheck <- sim_dataframe %>% 
            filter(colorBy_column %in% names(color_labels)) %>% 
            select(colorBy_column) %>% unique() %>% pull()
        obscheck <- obs_data %>% 
            filter(colorBy_column %in% names(color_labels)) %>% 
            select(colorBy_column) %>% unique() %>% pull()
        
        if(length(sort(unique(c(simcheck, obscheck)))) > 
           length(color_labels[names(color_labels) %in% sim_dataframe$colorBy_column])){
            warning(paste0("You have not included enough labels for the colors in the legend. The values in '",
                           as_label(colorBy_column), 
                           "' will be used as labels instead."),
                    call. = FALSE)
            color_labels <- NA
        } else {
            if(length(color_labels[names(color_labels) %in% sim_dataframe$colorBy_column]) == 0 |
               length(sort(unique(c(simcheck, obscheck)))) == 0){
                warning(paste0("There is some kind of mismatch between the color labels provided and the values actually present in ",
                               as_label(colorBy_column), ". The specified labels cannot be used."),
                        call. = FALSE)  
            } else {
                
                sim_dataframe <- sim_dataframe %>% 
                    mutate(colorBy_column = color_labels[colorBy_column], 
                           colorBy_column = factor(colorBy_column, levels = color_labels))
                
                obs_data <- obs_data %>% 
                    mutate(colorBy_column = color_labels[colorBy_column], 
                           colorBy_column = factor(colorBy_column, levels = color_labels))
            }
        }
    }
    
    # Taking care of linetypes
    NumLT <- length(unique(sim_dataframe$linetype_column))
    if(NumLT < length(linetypes)){ linetypes = linetypes[1:NumLT] }
    if(NumLT > length(linetypes)){ linetypes = rep(linetypes, 100)[1:NumLT]}
    
    # If the original data.frame included levels for linetype_column, then use
    # those levels. Otherwise, make "none" the base level since most of the
    # time, this will be used for the column "Inhibitor".
    if(class(sim_dataframe$linetype_column) != "factor"){
        if("none" %in% unique(sim_dataframe$linetype_column)){
            sim_dataframe <- sim_dataframe %>% 
                mutate(linetype_column = forcats::fct_relevel(linetype_column, "none"))
        } else {
            sim_dataframe$linetype_column <- as.factor(sim_dataframe$linetype_column)
        }
    }
    
    
    # Not sure how I'm going to relabel the facets, actually. Commenting this
    # out for now.
    
    # if(complete.cases(facet1_labels[1])){
    #     simcheck <- sim_dataframe %>% 
    #         filter(FC1 %in% names(facet1_labels)) %>% 
    #         select(FC1) %>% unique() %>% pull()
    #     obscheck <- obs_data %>% 
    #         filter(FC1 %in% names(facet1_labels)) %>% 
    #         select(FC1) %>% unique() %>% pull()
    #     
    #     if(length(sort(unique(c(simcheck, obscheck)))) > 
    #        length(facet1_labels[names(facet1_labels) %in% sim_dataframe$FC1])){
    #         warning(paste0("You have not included enough labels for number of unique values in ", 
    #                        as_label(FC1), 
    #                        ". The values will be used as labels instead."))
    #         facet1_labels <- NA
    #     } else {
    #         if(length(facet1_labels[names(facet1_labels) %in% sim_dataframe$FC1]) == 0 |
    #            length(sort(unique(c(simcheck, obscheck)))) == 0){
    #             warning(paste0("There is some kind of mismatch between the facet 1 labels provided and the values actually present in ",
    #                            as_label(FC1), ". The specified labels cannot be used."))  
    #             
    #             facet1_labels <- NA
    #         } 
    #     } # If facet1_labels is not NA at this point, apply those labels for the facets using labeller...? Not sure how this is going to work yet.
    # }
    # 
    # if(complete.cases(facet2_labels[1])){
    #     simcheck <- sim_dataframe %>% 
    #         filter(FC2 %in% names(facet2_labels)) %>% 
    #         select(FC2) %>% unique() %>% pull()
    #     obscheck <- obs_data %>% 
    #         filter(FC2 %in% names(facet2_labels)) %>% 
    #         select(FC2) %>% unique() %>% pull()
    #     
    #     if(length(sort(unique(c(simcheck, obscheck)))) > 
    #        length(facet2_labels[names(facet2_labels) %in% sim_dataframe$FC2])){
    #         warning(paste0("You have not included enough labels for number of unique values in ", 
    #                        as_label(FC2), 
    #                        ". The values will be used as labels instead."))
    #         
    #         facet2_labels <- NA
    #         
    #     } else {
    #         if(length(facet2_labels[names(facet2_labels) %in% sim_dataframe$FC2]) == 0 |
    #            length(sort(unique(c(simcheck, obscheck)))) == 0){
    #             warning(paste0("There is some kind of mismatch between the facet 1 labels provided and the values actually present in ",
    #                            as_label(FC2), ". The specified labels cannot be used."))  
    #             
    #             facet2_labels <- NA
    #         }
    #     }
    # } # If facet2_labels is not NA at this point, apply those labels for the facets using labeller...? Not sure how this is going to work yet.
    
    MyAES <- c("color" = as_label(colorBy_column), 
               "linetype" = as_label(linetype_column),
               "facet1" = as_label(facet1_column), 
               "facet2" = as_label(facet2_column))
    UniqueAES <- MyAES[which(MyAES != "<empty>")]
    
    MyUniqueData <- ct_dataframe %>% 
        filter(Trial == MyMeanType) %>% 
        select(union(UniqueAES, 
                     c("File", "Tissue", "CompoundID", "Compound", "Inhibitor"))) %>% 
        unique()
    
    UniqueGroups1 <- ct_dataframe %>% 
        summarize(across(.cols = union(UniqueAES, 
                                       c("File", "Tissue", "CompoundID",
                                         "Compound", "Inhibitor")),
                         .fns = function(x) length(unique(x)))) 
    
    UniqueGroups <- UniqueGroups1 %>% 
        t() %>% as.data.frame() %>% 
        mutate(MyCols = rownames(.)) %>% 
        filter(V1 > 1) %>% pull(MyCols)
    
    
    # If there are only 2 groups for the colorBy_column and color_set was set to
    # "default", use Brewer set 1 instead of Brewer set 2 b/c it's more
    # aethetically pleasing.
    if(UniqueGroups1 %>% select(as_label(colorBy_column)) %>% pull(1) <= 2 &
       color_set == "default"){
        color_set <- "Brewer set 1"
    }
    
    if(length(UniqueGroups[UniqueGroups != "Compound"]) > length(UniqueAES)){
        warning(paste("You have requested", length(UniqueGroups[UniqueGroups != "Compound"]),
                      "unique data sets but only", 
                      length(which(complete.cases(MyAES))), 
                      "unique aesthetics for denoting those datasets. This is may result in an unclear graph."),
                call. = FALSE)
        message(paste("Unique datasets:", str_comma(UniqueGroups)))
        message(paste("Unique aesthetics:", str_comma(UniqueAES)))
    }
    
    # If there are multiple values in linetype_column but user has only listed
    # the default "solid" for linetypes, then warn the user that they might want
    # to specify more line types.
    if(as_label(colorBy_column) != as_label(linetype_column) &&
       length(unique(ct_dataframe$linetype_column)) > 1 & 
       length(unique(linetypes)) == 1){
        warning(paste0("There are ", length(unique(ct_dataframe$linetype_column)),
                       " unique values in the column ", as_label(linetype_column),
                       ", but you have only requested ", 
                       length(unique(linetypes)), " linetype(s): ", 
                       str_comma(unique(linetypes)), 
                       ". You will get a more interpretable graph if you specify more values for the argument 'linetypes'."),
                call. = FALSE)
    }
    
    # Some of the options inherited from ct_plot depend on there being just one
    # compound that the user is plotting. Using whatever is the compoundID that
    # has the base level for the factor. <--- This may not be necessary, now
    # that I think about it further...
    AnchorCompound <- ct_dataframe %>% select(CompoundID) %>% unique() %>% 
        mutate(CompoundLevel = as.numeric(CompoundID)) %>% 
        filter(CompoundLevel == min(CompoundLevel)) %>% 
        pull(CompoundID) %>% as.character()
    
    # Setting up the x axis using the subfunction ct_x_axis
    ct_x_axis(Data = ct_dataframe,
              time_range = time_range, 
              t0 = "simulation start",
              x_axis_interval = x_axis_interval,
              pad_x_axis = pad_x_axis,
              compoundToExtract = AnchorCompound, EnzPlot = FALSE)
    
    # Setting up the y axis using the subfunction ct_y_axis
    ct_y_axis(Data = ct_dataframe, 
              ADAM = FALSE, 
              subsection_ADAM = "free compound in lumen", # This is just a placeholder since no ADAM data are currently allowed.
              EnzPlot = FALSE, 
              time_range_relative = time_range_relative,
              Ylim_data = ct_dataframe %>% mutate(Time_orig = Time), 
              pad_y_axis = pad_y_axis,
              y_axis_limits_lin = y_axis_limits_lin, 
              time_range = time_range,
              y_axis_limits_log = y_axis_limits_log)
    
    
    # Setting figure types ---------------------------------------------------
    ## Figure type: means only ---------------------------------------------
    if(figure_type == "means only"){
        A <- ggplot(sim_dataframe,
                    aes(x = Time, y = Conc, color = colorBy_column, 
                        linetype = linetype_column,
                        group = Group)) +
            geom_line()
        
        if(nrow(obs_data) > 0){
            if(InternalAssignFile){
                A <- A +
                    geom_point(data = obs_data, inherit.aes = FALSE,
                               aes(x = Time, y = Conc, group = Group), 
                               alpha = ifelse(complete.cases(obs_transparency), 
                                              obs_transparency, 1), 
                               show.legend = FALSE)
            } else {
                A <- A +
                    geom_point(data = obs_data, inherit.aes = FALSE,
                               aes(x = Time, y = Conc, group = Group,
                                   color = colorBy_column), 
                               alpha = ifelse(complete.cases(obs_transparency), 
                                              obs_transparency, 1), 
                               show.legend = FALSE)
            }
        }
    }
    
    
    ## Figure type: ribbon --------------------------------------------------
    if(str_detect(figure_type, "ribbon")){
        
        RibbonDF <-  sim_dataframe %>% 
            filter(Trial %in% c({MyMeanType}, "per5", "per95")) %>% 
            unique() %>% 
            select(-any_of(c("Group", "Individual"))) %>% 
            pivot_wider(names_from = Trial, values_from = Conc)
        names(RibbonDF)[names(RibbonDF) == MyMeanType] <- "MyMean"
        
        A <- ggplot(RibbonDF, aes(x = Time, y = MyMean, ymin = per5, ymax = per95, 
                                  color = colorBy_column, fill = colorBy_column, 
                                  linetype = linetype_column)) + 
            geom_ribbon(alpha = 0.25, color = NA) +
            geom_line()
        
        if(nrow(obs_data) > 0){
            if(InternalAssignFile){
                A <- A + 
                    geom_point(data = obs_data, 
                               aes(x = Time, y = Conc, group = Group),
                               inherit.aes = FALSE, 
                               alpha = ifelse(complete.cases(obs_transparency), 
                                              obs_transparency, 1), 
                               show.legend = FALSE) 
                
            } else {
                A <- A + 
                    geom_point(data = obs_data, 
                               aes(x = Time, y = Conc, group = Group,
                                   color = colorBy_column), 
                               inherit.aes = FALSE, 
                               alpha = ifelse(complete.cases(obs_transparency), 
                                              obs_transparency, 1), 
                               show.legend = FALSE) 
            }
        }
    }
    
    # Making linear graph --------------------------------------------------------
    A <-  A +
        xlab(paste0("Time (", unique(sim_dataframe$Time_units), ")")) +
        ylab(paste0("Concentration (", unique(sim_dataframe$Conc_units), ")")) +
        theme(panel.background = element_rect(fill = "white", color = NA),
              panel.border = element_rect(color = "black", fill = NA),
              strip.background = element_rect(fill = "white"),
              legend.key = element_rect(fill = "white"),
              axis.ticks = element_line(color = "black"),
              axis.text = element_text(color = "black"),
              axis.title = element_text(color = "black", face = "bold"),
              axis.line.y = element_line(color = "black"),
              axis.line.x.bottom = element_line(color = "black"))
    
    if(floating_facet_scale){
        A <- A + 
            scale_x_continuous(expand = expansion(
                mult = pad_x_num)) +
            scale_y_continuous(expand = expansion(mult = pad_y_num)) +
            facet_wrap(vars(!!facet1_column, !!facet2_column), 
                       scales = "free")
        
    } else {
        A <- A +
            coord_cartesian(xlim = time_range_relative, 
                            ylim = c(ifelse(is.na(y_axis_limits_lin[1]), 
                                            0, y_axis_limits_lin[1]),
                                     YmaxRnd)) +
            scale_x_continuous(breaks = XBreaks, labels = XLabels,
                               expand = expansion(
                                   mult = pad_x_num)) +
            scale_y_continuous(breaks = YBreaks,
                               labels = YLabels,
                               expand = expansion(mult = pad_y_num)) +
            facet_grid(rows = vars(!!facet1_column), cols = vars(!!facet2_column)) 
    }
    
    # Colors, linetypes, & legends -------------------------------------------
    
    # Adding options for colors
    colRainbow <- colorRampPalette(c("gray20", "antiquewhite4", "firebrick3",
                                     "darkorange", "green3", "seagreen3",
                                     "cadetblue", "dodgerblue3", "royalblue4",
                                     "darkorchid4"))
    
    blueGreen <- colorRampPalette(c("green3", "seagreen3", "cadetblue", 
                                    "dodgerblue3", "royalblue4"))
    
    NumColorsNeeded <- sim_dataframe %>% pull(MyAES["color"]) %>% 
        unique() %>% length()
    
    # print(NumColorsNeeded)
    
    if(length(sort(unique(ct_dataframe$colorBy_column))) == 1){
        A <- A + scale_color_manual(values = "black")
    } else {
        
        if(color_set == "default"){
            # Using "Dark2" b/c "Set2" is just really, really light. 
            A <- A + scale_color_brewer(palette = "Dark2") +
                scale_fill_brewer(palette="Dark2")
        }
        
        if(color_set == "blue-green"){
            A <- A + scale_color_manual(values = blueGreen(NumColorsNeeded)) +
                scale_fill_manual(values = blueGreen(NumColorsNeeded))
        }
        
        if(color_set == "rainbow"){
            A <- A + scale_color_manual(values = colRainbow(NumColorsNeeded)) +
                scale_fill_manual(values = colRainbow(NumColorsNeeded))
        }
        
        if(str_detect(tolower(color_set), "brewer.*2|set.*2")){
            # Using "Dark2" b/c "Set2" is just really, really light. 
            A <- A + scale_fill_brewer(palette = "Dark2") +
                scale_color_brewer(palette = "Dark2")
        }
        
        if(str_detect(tolower(color_set), "brewer.*1|set.*1")){
            A <- A + scale_fill_brewer(palette = "Set1") +
                scale_color_brewer(palette = "Set1")
        }
        
        if(color_set == "Tableau"){
            A <- A + ggthemes::scale_color_tableau() +
                ggthemes::scale_fill_tableau()
        }
    }
    
    # Specifying linetypes
    A <- A + scale_linetype_manual(values = linetypes)
    
    # Adding legend label for color and linetype as appropriate
    if(complete.cases(legend_label_color) &&
       legend_label_color == "none"){
        A <- A + labs(color = NULL, fill = NULL)
    } else {
        A <- A + labs(color = switch(as.character(complete.cases(legend_label_color)), 
                                     "TRUE" = legend_label_color, 
                                     "FALSE" = as_label(colorBy_column)), 
                      fill = switch(as.character(complete.cases(legend_label_color)), 
                                    "TRUE" = legend_label_color,
                                    "FALSE" = as_label(colorBy_column)))
    }
    
    
    if(complete.cases(legend_label_linetype) && 
       legend_label_linetype == "none"){
        A <- A + labs(linetype = NULL)
    } else {
        A <- A + labs(fill = switch(as.character(complete.cases(legend_label_color)), 
                                    "TRUE" = legend_label_color,
                                    "FALSE" = as_label(colorBy_column)))
    }
    
    ## Adding spacing between facets if requested
    if(complete.cases(facet_spacing)){
        A <- A + theme(panel.spacing = unit(facet_spacing, "lines"))
    }
    
    # If any of the items in the legend have length = 1, don't show that in the
    # legend.
    if(length(unique(sim_dataframe$linetype_column)) == 1 | 
       length(unique(linetypes)) == 1){
        A <- A + guides(linetype = "none") 
    }
    
    if(length(unique(sim_dataframe$colorBy_column)) == 1){
        A <- A + guides(color = "none")
    }
    
    ## Making semi-log graph ------------------------------------------------
    
    B <- suppressMessages(
        A + scale_y_log10(limits = Ylim_log, breaks = YLogBreaks,
                          labels = YLogLabels,
                          expand = expansion(mult = pad_y_num)) 
    )
    
    if(floating_facet_scale == FALSE){
        B <- suppressMessages(B + coord_cartesian(xlim = time_range_relative))
    }
    
    if(complete.cases(legend_position)){
        A <- A + theme(legend.position = legend_position)  
        B <- B + theme(legend.position = legend_position)
    }    
    
    if(graph_labels){
        labels <- "AUTO"
    } else {
        labels <- NULL
    }
    
    # both plots together, aligned vertically
    AB <- suppressWarnings(
        ggpubr::ggarrange(A, B, ncol = 1, labels = labels,
                          common.legend = TRUE, align = "hv", 
                          legend = ifelse(is.na(legend_position), 
                                          "right", legend_position))
    )
    
    # both plots together, aligned horizontally
    ABhoriz <- suppressWarnings(
        ggpubr::ggarrange(A, B, ncol = 2, labels = labels,
                          common.legend = TRUE, align = "hv", 
                          legend = ifelse(is.na(legend_position), 
                                          "bottom", legend_position))
    )
    
    Out <- switch(linear_or_log, 
                  "linear" = A,
                  "semi-log" = B,
                  "log" = B,
                  "both" = AB, 
                  "both vertical" = AB,
                  "both horizontal" = ABhoriz)
    
    if(complete.cases(save_graph)){
        FileName <- save_graph
        if(str_detect(FileName, "\\.")){
            # Making sure they've got a good extension
            Ext <- sub("\\.", "", str_extract(FileName, "\\..*"))
            FileName <- sub(paste0(".", Ext), "", FileName)
            Ext <- ifelse(Ext %in% c("eps", "ps", "jpeg", "tiff",
                                     "png", "bmp", "svg", "jpg"), 
                          Ext, "png")
            FileName <- paste0(FileName, ".", Ext)
        } else {
            FileName <- paste0(FileName, ".png")
        }
        
        if(linear_or_log %in% c("both", "both vertical")){
            ggsave(FileName, height = fig_height, width = fig_width, dpi = 600,
                   plot = AB)
        }
        
        if(linear_or_log %in% c("both horizontal")){
            ggsave(FileName, height = fig_height, width = fig_width, dpi = 600,
                   plot = ABhoriz)
        }
        
        if(linear_or_log == "linear"){
            ggsave(FileName, height = fig_height, width = fig_width, dpi = 600, 
                   plot = A)
        }
        
        if(str_detect(linear_or_log, "log")){
            ggsave(FileName, height = fig_height, width = fig_width, dpi = 600, 
                   plot = B)
        }
    }
    
    return(Out)
    
}




