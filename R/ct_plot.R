#' Concentration-time plots to match Consultancy template
#'
#' Using observed and simulated concentration-time data, make
#' publication-quality graphs that match the consultancy template formatting
#' instructions. We've tried to include a fair number of options here for
#' flexibility, but many of the function arguments are optional; most of the
#' time, you'll get decent-looking graphs while only setting a minimal number of
#' arguments. If you want to plot enzyme abundance data, please see
#' \code{\link{enz_plot}}. \strong{A few notes:} \enumerate{\item{Not all
#' substrate metabolites, inhibitors, or inhibitor metabolites are available in
#' all tissues.}\item{When observed data are included in a simulator output
#' file, because the simulator output does not explicitly say whether those
#' observed data were in the presence of an effector, this function cannot tell
#' the difference and will thus assume all observed data included in the
#' simulator output were for the substrate in the \emph{absence} of any
#' effector. It will further assume that the compound the observed data is for
#' is the same as \code{compoundToExtract}. If you want to specify which
#' compound the observed data were for and/or whether any effectors were
#' present, please supply an observed data file to the argument
#' \code{obs_data_file}.} \item{If you attempt to use data generated by
#' \code{\link{extractConcTime_mult}} here, you can get weird results if you're
#' not careful to only include one tissue and one compound ID. If you see
#' something odd, try including the legend to help decipher what might have gone
#' awry.}}
#'
#' @param ct_dataframe the input concentration-time data generated by running
#'   the function \code{\link{extractConcTime}}. Not quoted.
#' @param subsection_ADAM ADAM model only: For ADAM model output, multiple types
#'   of data are available. Which of those concentration types do you want to
#'   show? Options are whatever were available for that tissue, which could be
#'   "solid compound", "free compound in lumen", "Heff", "absorption rate",
#'   "unreleased substrate in faeces", "unreleased inhibitor in faeces",
#'   "dissolved compound", or "luminal CLint of compound". Default is "free
#'   compound in lumen" but is ignored when ct_dataframe isn't for ADAM data.
#' @param figure_type type of figure to plot. Options are:
#'
#'   \describe{
#'
#'   \item{"trial means"}{plots an opaque line for the mean data, lighter lines
#'   for the mean of each trial of simulated data, and open circles for the
#'   observed data. If an effector were present, lighter dashed lines indicate
#'   the mean of each trial of simulated data in the presence of the effector.}
#'
#'   \item{"percentiles"}{(default) plots an opaque line for the mean data,
#'   lighter lines for the 5th and 95th percentiles of the simulated data, and
#'   open circles for the observed data. If an effecter were present, the
#'   default is dashed lines for the data in the presence of an effector.}
#'
#'   \item{"percentile ribbon"}{plots an opaque line for the mean data,
#'   transparent shading for the 5th to 95th percentiles of the simulated data,
#'   and open circles for the observed data. If an effector were present, the
#'   default is to show the data without the effector in blue and the data in
#'   the presence of the effector in red. Note: You may sometimes see some
#'   artifacts -- especially for semi-log plots -- where the ribbon gets partly
#'   cut off. For arcane reasons we don't want to bore you with here, we can't
#'   easily prevent this. However, a possible fix is to set your y axis limits
#'   for the semi-log plot to be wider using \code{y_axis_limits_log}.}
#'
#'   \item{"means only"}{plots a black line for the mean data and, if an
#'   effector was modeled, a dashed line for the concentration-time data with
#'   Inhibitor 1.}
#'
#'   \item{"Freddy"}{Freddy's favorite style of plot with trial means in light
#'   gray, the overall mean in thicker black, the 5th and 95th percentiles in
#'   dashed lines, and the observed data in semi-transparent purple-blue. Graphs
#'   with an effector present lose the trial means, and the percentiles switch
#'   to solid, gray lines. \strong{An editorial comment:} While this does not
#'   align with the officially sanctioned template at this time, this looks
#'   \emph{sharp}, makes it easy to see the defining characteristics of the
#'   data, and I recommend checking it out, even just for your own purposes of
#'   examining your data. If the color is too much for you but you like the
#'   rest, try setting \code{obs_color = "none"}. -LS}}
#'
#' @param mean_type graph "arithmetic" (default) or "geometric" means or
#'   "median" for median concentrations
#' @param time_range time range to show relative to the start of the simulation.
#'   Options: \describe{
#'
#'   \item{NA}{(default) entire time range of data}
#'
#'   \item{a start time and end time in hours}{only data in that time range,
#'   e.g. \code{c(24, 48)}. Note that there are no quotes around numeric data.}
#'
#'   \item{"first dose"}{only the time range of the first dose}
#'
#'   \item{"last dose"}{only the time range of the last dose}
#'
#'   \item{"penultimate dose"}{only the time range of the 2nd-to-last dose,
#'   which can be useful for BID data where the end of the simulation extended
#'   past the dosing interval or data when the substrate was dosed BID and the
#'   effector was dosed QD}
#'
#'   \item{a specific dose number with "dose" or "doses" as the prefix}{the time
#'   range encompassing the requested doses, e.g., \code{time_range = "dose 3"}
#'   for the 3rd dose or \code{time_range = "doses 1 to 4"} for doses 1 to 4}
#'
#'   \item{"all obs" or "all observed" if you feel like spelling it out}{Time
#'   range will be limited to only times when observed data are present.}
#'
#'   \item{"last dose to last observed" or "last obs" for short}{Time range will
#'   be limited to the start of the last dose until the last observed data
#'   point.}
#'
#'
#'   }
#'
#' @param t0 What event should be used for time zero? Options are: "simulation
#'   start" (default), "dose 1", "penultimate dose", or "last dose". \emph{This
#'   does not change which data are included in the graph;} instead, this
#'   determines whether the x axis numbers are offset so that, e.g., the last
#'   dose is administered at time 0.
#'
#' @param adjust_obs_time TRUE or FALSE (default) for whether to adjust the time
#'   listed in the observed data file to match the last dose administered. This
#'   only applies to multiple-dosing regimens. If TRUE, the graph will show the
#'   observed data overlaid with the simulated data such that the dose in the
#'   observed data was administered at the same time as the last dose in the
#'   simulated data. If FALSE, the observed data will start at whatever times
#'   are listed in the Excel file.
#' @param pad_x_axis optionally add a smidge of padding to the the x axis
#'   (default is TRUE, which includes some generally reasonable padding). If
#'   changed to FALSE, the y axis will be placed right at the beginning of your
#'   time range and all data will end \emph{exactly} at the end of the time
#'   range specified. If you want a \emph{specific} amount of x-axis padding,
#'   set this to a number; the default is \code{c(0.02, 0.04)}, which adds 2\%
#'   more space to the left side and 4\% more to the right side of the x axis.
#'   If you only specify one number, we'll assume that's the percent you want
#'   added to the left side.
#' @param pad_y_axis optionally add a smidge of padding to the y axis (default
#'   is TRUE, which includes some generally reasonable padding). As with
#'   \code{pad_x_axis}, if changed to FALSE, the x axis will be placed right at
#'   the bottom of your data, possible cutting a point in half. If you want a
#'   \emph{specific} amount of y-axis padding, set this to a number; the default
#'   is \code{c(0.02, 0)}, which adds 2\% more space to the bottom and nothing
#'   to the top of the y axis. If you only specify one number, we'll assume
#'   that's the percent you want added to the bottom.
#' @param x_axis_interval optionally set the x-axis major tick-mark interval.
#'   Acceptable input: any number or leave as NA to accept default values, which
#'   are generally reasonable guesses as to aesthetically pleasing and
#'   PK-relevant intervals.
#' @param y_axis_limits_lin optionally set the Y axis limits for the linear
#'   plot, e.g., \code{c(10, 1000)}. If left as the default NA, the Y axis
#'   limits for the linear plot will be automatically selected.
#' @param y_axis_limits_log optionally set the Y axis limits for the semi-log
#'   plot, e.g., \code{c(10, 1000)}. Values will be rounded down and up,
#'   respectively, to a round number. If left as the default NA, the Y axis
#'   limits for the semi-log plot will be automatically selected.
#' @param obs_color If you would like the observed data points to be in color,
#'   either specify a color here or set this to "default". Points will be
#'   displayed in semi-transparent blue-purple for "default" and the
#'   semi-transparent version of whatever other color you list otherwise.
#'   Setting this to "none" will make sure that the symbols are black outlines
#'   only with no fill. Hex color codes are also ok to use. If left as NA, all
#'   observed data will be in black.
#' @param obs_shape optionally specify what shapes are used to depict observed
#'   data for 1. the substrate drug alone and 2. the substrate drug in the
#'   presence of an effector. Input should look like this, for example:
#'   \code{c(1, 2)} to get an open circle and an open triangle. To see all the
#'   possible shapes and what number corresponds to which shape, see
#'   \url{https://r-graphics.org/recipe-scatter-shapes} (there's a graph around
#'   the middle of that page). If left as NA, substrate alone will be an open
#'   circle and substrate + inhibitor 1 will be an open triangle.
#' @param showBLQ TRUE or FALSE (default) to display observed concentrations
#'   that were clearly below the lower limit of quantitation, that is,
#'   concentrations equal to 0 after time 0. The default (FALSE) removes these
#'   values so that they will not show up on graphs.
#' @param line_transparency optionally specify the transparency for the trial
#'   mean or percentile lines. Acceptable values are from 0 (fully transparent,
#'   so no line at all) to 1 (completely opaque or black). If left as the
#'   default NA, this value will be automatically determined.
#' @param line_type Optionally specify what types of lines are used to depict
#'   \enumerate{\item{the substrate drug alone and} \item{the substrate drug in
#'   the presence of an effector (when applicable).}} Input should look like
#'   this, for example: \code{c("solid", "dashed")} to get a solid line for the
#'   substrate drug and a dashed line for inhibitor 1. \itemize{ \item{To see
#'   all possible \code{line_type} options: \code{ggpubr::show_line_types()}}
#'   \item{If left as NA, substrate alone will be a solid line and substrate +
#'   inhibitor 1 will be a dashed line.} \item{If \code{figure_type} is "Freddy"
#'   and there's no effector present, which is a slightly different scenario
#'   than the other graph types, the 1st line type specified will be for the
#'   mean simulated concentration and the trial means, and the 2nd line type
#'   specified will be for the 5th and 95th percentiles.}}
#' @param line_color optionally specify what colors to use for the lines.
#'   Acceptable input for, e.g., the substrate alone to be blue and the
#'   substrate + Inhibitor 1 to be red: \code{c("blue", "red")}. If left as the
#'   default NA, lines will be black or gray. Hex color codes are also
#'   acceptable to use.
#' @param line_width optionally specify how thick to make the lines. Acceptable
#'   input is a number; the default is 1 for most lines and 0.8 for some, to
#'   give you an idea of where to start.
#' @param graph_labels TRUE or FALSE for whether to include labels (A, B, C,
#'   etc.) for each of the small graphs. (Not applicable if only outputting
#'   linear or only semi-log graphs.)
#' @param legend_label optionally indicate on the legend whether the effector is
#'   an inhibitor, inducer, activator, or suppressor. Input will be used as the
#'   label in the legend for the line style and the shape. If left as the
#'   default NA when a legend is included and an effector is present, the label
#'   in the legend will be "Inhibitor".
#' @param prettify_compound_names TRUE (default) or FALSE on whether to make
#'   compound names prettier in legend entries and in any Word output files.
#'   This was designed for simulations where the substrate and any metabolites,
#'   effectors, or effector metabolites are among the standard options for the
#'   simulator, and leaving \code{prettify_compound_names = TRUE} will make the
#'   name of those compounds something more human readable. For example,
#'   "SV-Rifampicin-MD" will become "rifampicin", and "Sim-Midazolam" will
#'   become "midazolam". Set each compound to the name you'd prefer to see in
#'   your legend and Word output if you would like something different. For
#'   example, \code{prettify_compound_names = c("inhibitor" = "defartinib",
#'   "substrate" = "superstatin")}. Please note that "inhibitor" includes
#'   \emph{all} the effectors and effector metabolites present, so, if you're
#'   setting the effector name, you really should use something like this if
#'   you're including effector metabolites: \code{prettify_compound_names =
#'   c("inhibitor" = "defartinib and 1-OH-defartinib", "substrate" =
#'   "superstatin")}.
#' @param linear_or_log the type of graph to be returned. Options: \describe{
#'   \item{"semi-log"}{y axis is log transformed}
#'
#'   \item{"linear"}{no axis transformation}
#'
#'   \item{"both vertical"}{(default) both the linear and the semi-log graphs
#'   will be returned, and graphs are stacked vertically}
#'
#'   \item{"both horizontal"}{both the linear and the semi-log graphs will be
#'   returned, and graphs are stacked horizontally}}
#' @param legend_position specify where you want the legend to be. Options are
#'   "left", "right", "bottom", "top", or "none" (default) if you don't want one
#'   at all.
#' @param save_graph optionally save the output graph by supplying a file name
#'   in quotes here, e.g., "My conc time graph.png" or "My conc time
#'   graph.docx". If you leave off ".png" or ".docx" from the file name, it will
#'   be saved as a png file, but if you specify a different graphical file
#'   extension, it will be saved as that file format. Acceptable graphical file
#'   extensions are "eps", "ps", "jpeg", "jpg", "tiff", "png", "bmp", or "svg".
#'   Leaving this as NA means the file will not be saved to disk.
#'   \strong{WARNING:} SAVING TO WORD DOES NOT WORK ON SHAREPOINT. This is a
#'   Microsoft permissions issue, not an R issue. If you try to save on
#'   SharePoint, you will get a warning that R will save your file instead to
#'   your Documents folder. 
#' @param fig_height figure height in inches; default is 6
#' @param fig_width figure width in inches; default is 5
#'
#' @return Output is a graph.
#' @import tidyverse
#' @export
#'
#' @examples
#' # # Normal syntax with a fake file:
#' # sim_data_file <- "../Example simulator output.xlsx"
#' # obs_data_file <- "../fig1-242-06-001-MD - for XML conversion.xlsx"
#'
#' # However, since we can't load an Excel file as an example, here are
#' # some data to play with:
#' data(LMVct)
#'
#' ct_plot(ct_dataframe = LMVct)
#' ct_plot(ct_dataframe = LMVct, figure_type = "percentiles")
#' ct_plot(ct_dataframe = LMVct)
#' ct_plot(ct_dataframe = LMVct)
#'
#' # Perhaps you don't want to show *all* the data but instead want to
#' # limit the time interval that is graphed. Use \code{time_range} here:
#' ct_plot(ct_dataframe = LMVct, time_range = c(0, 24))
#'
#' # Or you can let it automatically calculate the time frame
#' # for a given set of doses
#' ct_plot(ct_dataframe = LMVct
#'         time_range = "first dose")
#' ct_plot(ct_dataframe = LMVct,
#'         time_range = "last dose")
#'
#' # The default graph may be too busy when Inhibitor 1 is present,
#' # so you may want to consider only plotting means as an alternative:
#' ct_plot(ct_dataframe = LMVct,
#'         figure_type = "means only")
#'
#' # Add some further options for the look of your graph -- especially useful
#' # if the default settings are clipping your data.
#' ct_plot(ct_dataframe = LMVct,
#'         obs_color = "red",
#'         line_color = "blue",
#'         y_axis_limits_log = c(50, 2000),
#'         pad_x_axis = TRUE,
#'         legend_label = "Inhibitor")

ct_plot <- function(ct_dataframe = NA,
                    figure_type = "percentiles",
                    subsection_ADAM = "free compound in lumen",
                    mean_type = "arithmetic", 
                    time_range = NA,
                    x_axis_interval = NA,
                    pad_x_axis = TRUE,
                    pad_y_axis = TRUE,
                    adjust_obs_time = FALSE,
                    t0 = "simulation start",
                    y_axis_limits_lin = NA,
                    y_axis_limits_log = NA,
                    obs_color = NA,
                    obs_shape = NA,
                    showBLQ = FALSE, 
                    line_type = NA,
                    line_transparency = NA,
                    line_color = NA,
                    line_width = NA,
                    legend_position = "none", 
                    legend_label = NA,
                    prettify_compound_names = TRUE,
                    linear_or_log = "both vertical",
                    graph_labels = TRUE,
                    save_graph = NA,
                    fig_height = 6,
                    fig_width = 5){
    
    # Error catching ----------------------------------------------------------
    
    # Check whether tidyverse is loaded
    if("package:tidyverse" %in% search() == FALSE){
        stop("The SimcypConsultancy R package also requires the package tidyverse to be loaded, and it doesn't appear to be loaded yet. Please run `library(tidyverse)` and then try again.")
    }
    
    if(length(figure_type) != 1 |
       figure_type %in% c("trial means", "percentiles", "trial percentiles",
                          "Freddy", "means only", "overlay", 
                          "percentile ribbon", "percentile ribbons", 
                          "ribbon") == FALSE){
        stop("The only acceptable options for figure_type are 'trial means', 'percentiles', 'percentile ribbon', 'means only', or 'Freddy'.",
             call. = FALSE)
    }
    
    if(length(unique(ct_dataframe$Conc_units)) > 1){
        stop("It looks like you have more than one kind of data here because you have multiple concentration units. Maybe you've got more than one ADAM-model tissue included? Because this function has been set up to deal with only one dataset at a time, no graph can be made. Please check your data and try this function with only one dataset at a time.")
    }
    
    if(length(unique(ct_dataframe$Compound)) > 1 | 
       length(unique(ct_dataframe$CompoundID)) > 1){
        stop("It looks like you have more than one kind of data here because you have multiple compounds. Did you perhaps mean to use the function ct_plot_overlay instead? Because this function has been set up to deal with only one dataset at a time, no graph can be made. Please check your data and try this function with only one dataset at a time.")
    }
    
    if(length(unique(ct_dataframe$Inhibitor)) > 2){
        stop("It looks like you have more than one kind of data here because you have multiple sets of inhibitors. Did you perhaps mean to use the function ct_plot_overlay instead? Because this function has been set up to deal with only one dataset at a time, no graph can be made. Please check your data and try this function with only one dataset at a time.")
    }
    
    
    # Main body of function --------------------------------------------------
    # If user had already filtered ct_dataframe to include only the ADAM data
    # they wanted, the subsection_ADAM column might not include the default
    # value for subsection_ADAM. In that case, just switch to the subsection
    # that *was* included and make the plot.
    if(subsection_ADAM == "free compound in lumen" & 
       length(unique(ct_dataframe$subsection_ADAM)) == 1 && 
       unique(ct_dataframe$subsection_ADAM) %in% 
       c("solid compound", "Heff", "absorption rate",
         "unreleased substrate in faeces", "unreleased inhibitor in faeces",
         "dissolved compound", "luminal CLint of compound", 
         paste("cumulative fraction of absorbed", 
               unique(ct_dataframe$CompoundID)),
         paste("cumulative fraction of dissolved",
               unique(ct_dataframe$CompoundID)))){
        subsection_ADAM <- unique(ct_dataframe$subsection_ADAM)
    }
    
    MyMeanType <- ct_dataframe %>%
        filter(Trial %in% c("geomean", "mean", "median")) %>% 
        pull(Trial) %>% unique() %>% 
        factor(levels = c("mean", "geomean", "median")) %>% 
        sort()
    
    if(switch(mean_type, "arithmetic" = "mean", "geometric" = "geomean",
              "median" = "median") %in% ct_dataframe$Trial == FALSE){
        
        warning(paste0("You requested the ", 
                       switch(mean_type, "arithmetic" = "arithmetic means",
                              "geometric" = "geometric means", 
                              "median" = "medians"), 
                       ", but those are not included in your data. Instead, the ",
                       ifelse(MyMeanType[1] == "mean", 
                              "arithmetic mean", MyMeanType[1]),
                       "s will be used."),
                call. = FALSE)
        MyMeanType <- MyMeanType[1] %>% as.character()
        
    } else {
        MyMeanType <- switch(mean_type, "arithmetic" = "mean", "geometric" = "geomean",
                             "median" = "median")
    }
    
    Data <- ct_dataframe %>% 
        # Making sure we only have one summary aggregate measurement
        filter(! Trial %in% setdiff(c("mean", "geomean", "median"), 
                                    MyMeanType))
    
    # Set compoundToExtract to whatever compound was included.
    EnzPlot <- "Enzyme" %in% names(Data)
    compoundToExtract <- ifelse(EnzPlot, unique(Data$Enzyme), 
                                unique(Data$CompoundID))
    if(EnzPlot){
        Data <- Data %>% mutate(CompoundID = Enzyme) %>%
            rename(Conc = Abundance) %>%
            mutate(Simulated = TRUE,
                   Compound = Enzyme)
    }
    
    # Noting whether the tissue was from an ADAM model
    ADAM <- unique(Data$Tissue) %in% c("stomach", "duodenum", "jejunum I",
                                       "jejunum II", "ileum I", "ileum II",
                                       "ileum III", "ileum IV", "colon", 
                                       "faeces", "cumulative absorption", 
                                       "cumulative dissolution") &&
        EnzPlot == FALSE
    
    # If the tissue was an ADAM tissue, only include the subsection_ADAM they requested. 
    if(ADAM){
        
        if(length(subsection_ADAM) > 1){
            stop("You can only enter one option for the concentration type for ADAM-model tissues. Please set subsection_ADAM to one of 'solid compound', 'free compound in lumen', 'Heff', 'absorption rate', 'unreleased substrate in faeces', 'unreleased inhibitor in faeces', 'dissolved compound', or 'luminal CLint of compound'",
                 call. = FALSE)
        }
        
        if(subsection_ADAM %in% c("solid compound", "free compound in lumen",
                                  "Heff", "absorption rate", 
                                  "unreleased substrate in faeces",
                                  "unreleased inhibitor in faeces",
                                  "dissolved compound",
                                  paste("cumulative fraction of absorbed", 
                                        unique(ct_dataframe$CompoundID)),
                                  paste("cumulative fraction of dissolved",
                                        unique(ct_dataframe$CompoundID)),
                                  "luminal CLint of compound") == FALSE){
            stop(paste0("The concentration type you requested, ", subsection_ADAM,
                        ", is not one of the options. Please set this value to one of 'solid compound', 'free compound in lumen', 'Heff', 'absorption rate', 'unreleased substrate in faeces', 'unreleased inhibitor in faeces', 'dissolved compound', or 'luminal CLint of compound'"),
                 call. = FALSE)
        }
        
        Data <- Data %>% filter(subsection_ADAM == {{subsection_ADAM}})
    }
    
    # You can't graph trial means if you didn't extract the individual data
    # (this is one of the rare instances where we DO calculate things rather
    # than pulling directly from the simulator output), so issuing an error if
    # that's the case.
    if(figure_type %in% c("trial means", "Freddy") &
       suppressWarnings(length(sort(as.numeric(
           as.character(unique(Data$Trial)))))) == 0){
        warning("The figure type selected requires the calculation of trial means, but the individual data were not supplied. Only the overall aggregate data will be displayed.",
                call. = FALSE)
    }
    
    # Setting up the x axis using the subfunction ct_x_axis
    ct_x_axis(Data = Data, time_range = time_range, t0 = t0,
              x_axis_interval = x_axis_interval, pad_x_axis = pad_x_axis,
              compoundToExtract = compoundToExtract, EnzPlot = EnzPlot)
    
    # Dealing with possible inhibitor 1 data ---------------------------------
    # Adding a grouping variable to data and also making the inhibitor 1 name
    # prettier for the graphs.
    MyEffector <- unique(Data$Inhibitor) %>% as.character()
    MyEffector <- MyEffector[!MyEffector == "none"]
    
    if(length(MyEffector) > 0 && complete.cases(MyEffector)){
        
        Data <- Data %>%
            mutate(CompoundIsEffector = Compound == MyEffector,
                   Inhibitor = as.character(ifelse(is.na(Inhibitor),
                                                   "none", Inhibitor)))
        
        if(class(prettify_compound_names) == "logical" &&
           prettify_compound_names){
            MyEffector <- prettify_compound_name(MyEffector)
        }
        
        if(class(prettify_compound_names) == "character"){
            MyEffector <- prettify_compound_names["inhibitor"]
        }
        
        Data <- 
            Data %>%
            mutate(Compound = ifelse(CompoundIsEffector, MyEffector, Compound),
                   Inhibitor = ifelse(Inhibitor != "none", MyEffector, Inhibitor),
                   Group = paste(Compound, Inhibitor, Trial)) %>%
            select(-CompoundIsEffector)
    }
    
    # Error catching for when user specifies linetype, color or shape and
    # doesn't include enough values when effector present
    if(complete.cases(obs_shape[1]) && length(MyEffector) > 0 &&
       complete.cases(MyEffector) &&
       compoundToExtract != "inhibitor 1" &&
       length(complete.cases(obs_shape)) < 2){
        warning("There is an inhibitor or effector present and you have specified what the symbol shapes should be, but you have not listed enough values (you need 2). The default shapes will be used.",
                call. = FALSE)
        obs_shape <- NA
    }
    
    if(complete.cases(obs_color[1]) && length(MyEffector) > 0 &&
       complete.cases(MyEffector) &&
       compoundToExtract != "inhibitor 1" &&
       length(complete.cases(obs_color)) < 2){
        warning("There is an inhibitor or effector present and you have specified what the symbol colors should be, but you have not listed enough values (you need 2). The default colors will be used.",
                call. = FALSE)
        obs_color <- NA
    }
    
    if(complete.cases(line_color[1]) && length(MyEffector) > 0 &&
       complete.cases(MyEffector) &&
       compoundToExtract != "inhibitor 1" &&
       length(complete.cases(line_color)) < 2){
        warning("There is an inhibitor or effector present and you have specified what the line colors should be, but you have not listed enough values (you need 2). The default colors will be used.",
                call. = FALSE)
        line_color <- NA
    }
    
    if(complete.cases(line_type[1]) && length(MyEffector) > 0 &&
       complete.cases(MyEffector) &&
       compoundToExtract != "inhibitor 1" &&
       length(complete.cases(line_type)) < 2){
        warning("There is an inhibitor or effector present and you have specified what the line types should be, but you have not listed enough values (you need 2). The default line types will be used.",
                call. = FALSE)
        line_type <- NA
    }
    
    # Always want "none" to be the 1st item on the legend, and we need there
    # to be some value present for "Inhibitor" for function to work correctly.
    Data <- Data %>%
        mutate(Inhibitor = ifelse(is.na(Inhibitor), "none", Inhibitor))
    if(length(MyEffector) > 0){
        Data <- Data %>%
            mutate(Inhibitor = factor(Inhibitor, levels = c("none", MyEffector)))
    }
    
    # Setting up data.frames to graph ---------------------------------------
    # Separating the data by type and calculating trial means
    suppressMessages(
        sim_data_trial <- Data %>%
            filter(Simulated == TRUE &
                       Trial %in% c("mean", "geomean", "per5", "per95", 
                                    "per10", "per90", "median") == FALSE) %>%
            group_by(across(any_of(c("Compound", "Tissue", "Inhibitor",
                                     "Simulated", "Trial", "Group",
                                     "Time", "Time_orig",
                                     "Time_units", "Conc_units")))) %>%
            summarize(Conc = switch(mean_type, 
                                    "arithmetic" = mean(Conc, na.rm = T),
                                    "geometric" = gm_mean(Conc, na.rm = T),
                                    "median" = median(Conc, na.rm = T))) %>%
            ungroup()
    )
    
    sim_data_mean <- Data %>%
        filter(Simulated == TRUE  &
                   Trial %in% c(MyMeanType, "per5", "per95")) %>%
        mutate(Group = paste(Compound, Inhibitor, Trial))
    
    # Setting up observed data per user input -------------------------------
    
    obs_data <- Data %>% filter(Simulated == FALSE) %>% droplevels()
    
    if(showBLQ == FALSE){
        obs_data <- obs_data %>% 
            mutate(Conc = ifelse(Conc <= 0 & Time > 0,
                                 NA, Conc)) %>% 
            filter(complete.cases(Conc)) 
    }
    
    # Checking whether there are multiple observations at each time point. If
    # so, user should probably be using figure_type = "percentiles" and, if not,
    # user should probably be using figure_type = "trial means", and Hannah
    # would like user to get a warning about that.
    suppressMessages(
        check <- obs_data %>% group_by(CompoundID, Inhibitor, Time) %>% 
            summarize(N = n())
    )
    
    if(nrow(obs_data) > 0 && any(check$N > 1) & figure_type %in% c("trial means")){
        warning(paste0("You have requested a figure type of '", 
                       figure_type, 
                       "', but you appear to be plotting individual observed data (N > 1 at each time point). You may want to switch to a figure type of 'percentiles' or 'percentile ribbon' to comply with the recommendations of the Simcyp Consultancy Team report template. Please see red text at the beginning of section 4 in the template."),
                call. = FALSE)
    }
    
    if(nrow(obs_data) > 0 && all(check$N == 1) & figure_type %in% c("percentiles", "percentile",
                                                                    "percentile ribbon", "ribbon")){
        warning(paste0("You have requested a figure type of '", 
                       figure_type, 
                       "', but you appear to be plotting mean observed data (N = 1 at each time point). You may want to switch to a figure type of 'trial means' or 'means only' to comply with the recommendations of the Simcyp Consultancy Team report template. Please see red text at the beginning of section 4 in the template."),
                call. = FALSE)
    }
    
    
    # Setting up the y axis using the subfunction ct_y_axis -------------------
    
    # Setting Y axis limits for both linear and semi-log plots
    if (figure_type == "trial means") {
        Ylim_data <- bind_rows(sim_data_trial, obs_data)
    } else if (str_detect(figure_type, "percentiles|Freddy|ribbon")) {
        Ylim_data <- bind_rows(sim_data_trial, sim_data_mean, obs_data)
    } else if (figure_type == "means only") {
        Ylim_data <- sim_data_mean %>% filter(as.character(Trial) == MyMeanType) 
    }
    
    if(nrow(Ylim_data) == 0){
        Ylim_data <- bind_rows(sim_data_trial, obs_data, sim_data_mean)
    }
    
    ct_y_axis(Data = Data, ADAM = ADAM, subsection_ADAM = subsection_ADAM,
              EnzPlot = EnzPlot, time_range_relative = time_range_relative,
              Ylim_data = Ylim_data, 
              pad_y_axis = pad_y_axis,
              y_axis_limits_lin = y_axis_limits_lin, time_range = time_range,
              y_axis_limits_log = y_axis_limits_log)
    
    
    # Figure types ---------------------------------------------------------
    
    set_aesthet(line_type = line_type, figure_type = figure_type,
                MyEffector = MyEffector, compoundToExtract = compoundToExtract, 
                obs_shape = obs_shape, obs_color = obs_color, 
                line_color = line_color)
    
    ## figure_type: trial means -----------------------------------------------------------
    if(figure_type == "trial means"){
        
        NumTrials <- length(unique(sim_data_trial$Trial))
        AlphaToUse <- ifelse(complete.cases(line_transparency),
                             line_transparency,
                             ifelse(NumTrials > 10, 0.05, 0.2))
        
        if(length(MyEffector) > 0 && complete.cases(MyEffector[1]) &&
           MyEffector[1] != "none" & compoundToExtract != "inhibitor 1"){
            
            warning("When there is an effector present in the simulation, as is the case here, the Simcyp Consultancy report template recommends only showing the means. You may want to change figure_type to 'means only'.",
                    call. = FALSE)
            
            ## linear plot
            A <- ggplot(sim_data_trial,
                        aes(x = Time, y = Conc, group = Group,
                            linetype = Inhibitor, shape = Inhibitor,
                            color = Inhibitor, fill = Inhibitor)) +
                geom_line(alpha = AlphaToUse, 
                          lwd = ifelse(is.na(line_width), 1, line_width), 
                          show.legend = FALSE) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial == MyMeanType), 
                          lwd = ifelse(is.na(line_width), 1, line_width)) +
                scale_shape_manual(values = obs_shape[1:2]) +
                scale_linetype_manual(values = line_type[1:2]) +
                scale_color_manual(values = line_color[1:2])
            
            if(nrow(obs_data) > 0){
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <-  A + geom_point(data = obs_data, size = 2,
                                         stroke = 1, fill = NA)
                } else {
                    # Glitch when the user has supplied observed data
                    # with a different number of inhibitors than
                    # sim_data_trial, e.g., when the obs data came
                    # with the simulator output file. Addressing that.
                    if(length(unique(obs_data$Inhibitor)) == 1){
                        obs_color <- obs_color[1]
                    }
                    
                    A <- A +
                        geom_point(data = obs_data, size = 2,
                                   alpha = 0.5, stroke = 1) +
                        scale_fill_manual(values = obs_color) +
                        # have to add geom_point 2x b/c alpha applies to both
                        # color (as in, the outline of the point) AND the fill
                        # of the point
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, stroke = 1)
                }
            }
            
        } else {
            
            ## linear plot
            A <- ggplot(sim_data_trial,
                        aes(x = Time, y = Conc, group = Trial)) +
                geom_line(alpha = AlphaToUse,
                          lwd = ifelse(is.na(line_width), 1, line_width),
                          linetype = line_type[1],
                          color = line_color[1]) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial == MyMeanType),
                          lwd = ifelse(is.na(line_width), 1, line_width),
                          linetype = line_type[1],
                          color = line_color[1])
            
            if(nrow(obs_data) > 0){
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + geom_point(data = obs_data, size = 2,
                                        shape = obs_shape[1], stroke = 1, 
                                        fill = NA)
                } else {
                    
                    A <- A + geom_point(data = obs_data, size = 2,
                                        fill = obs_color[1], alpha = 0.5,
                                        shape = obs_shape[1], stroke = 1) +
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, shape = obs_shape[1], stroke = 1)
                }
            }
        }
    }
    
    ## figure_type: percentiles ----------------------------------------------------------
    if(str_detect(figure_type, "percentile") &&
       !str_detect(figure_type, "ribbon")){
        # graphs with 95th percentiles
        
        AlphaToUse <- ifelse(complete.cases(line_transparency),
                             line_transparency, 0.25)
        
        if(length(MyEffector) > 0 && complete.cases(MyEffector[1]) &&
           MyEffector[1] != "none" & compoundToExtract != "inhibitor 1"){
            
            warning("When there is an effector present in the simulation, as is the case here, the Simcyp Consultancy report template recommends only showing the means. You may want to change figure_type to 'means only'.",
                    call. = FALSE)
            
            A <- ggplot(sim_data_mean %>%
                            filter(Trial %in% c("per5", "per95")) %>%
                            mutate(Group = paste(Group, Trial)),
                        aes(x = Time, y = Conc,
                            linetype = Inhibitor, shape = Inhibitor,
                            color = Inhibitor, fill = Inhibitor, 
                            group = Group)) +
                geom_line(alpha = AlphaToUse, 
                          lwd = ifelse(is.na(line_width), 0.8, line_width)) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial == MyMeanType),
                          lwd = ifelse(is.na(line_width), 1, line_width))  +
                scale_shape_manual(values = obs_shape[1:2]) +
                scale_linetype_manual(values = line_type[1:2]) +
                scale_color_manual(values = line_color[1:2])
            
            if(nrow(obs_data) > 0){
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + geom_point(data = obs_data, size = 2,
                                        stroke = 1, fill = NA)
                } else {
                    A <- A +
                        geom_point(data = obs_data, size = 2,
                                   alpha = 0.5, stroke = 1) +
                        scale_fill_manual(values = obs_color) +
                        # have to add geom_point 2x b/c alpha applies to both
                        # color (as in, the outline of the point) AND the fill
                        # of the point
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, stroke = 1)
                }
            }
            
        } else {
            
            ## linear plot
            A <- ggplot(sim_data_mean %>% filter(Trial != MyMeanType),
                        aes(x = Time, y = Conc, group = Trial)) +
                geom_line(alpha = AlphaToUse, 
                          lwd = ifelse(is.na(line_width), 0.8, line_width),
                          linetype = line_type[1],
                          color = line_color[1]) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial == MyMeanType),
                          lwd = ifelse(is.na(line_width), 1, line_width),
                          linetype = line_type[1],
                          color = line_color[1])
            
            if(nrow(obs_data) > 0){
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + geom_point(data = obs_data, size = 2,
                                        stroke = 1, shape = obs_shape[1])
                } else {
                    A <- A +
                        geom_point(data = obs_data, size = 2,
                                   fill = obs_color[1], alpha = 0.5,
                                   stroke = 1, shape = obs_shape[1]) +
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, shape = obs_shape[1], stroke = 1)
                }
            }
        }
    }
    
    ## figure_type: percentile ribbon ----------------------------------------------------------
    if(str_detect(figure_type, "ribbon")){
        # graphs with 95th percentiles as transparent ribbons 
        
        AlphaToUse <- ifelse(complete.cases(line_transparency),
                             line_transparency, 0.25)
        
        RibbonDF <- sim_data_mean %>% select(-Group, -Individual) %>% 
            pivot_wider(names_from = Trial, values_from = Conc) %>% 
            rename("mean" = {MyMeanType})
        
        
        if(length(MyEffector) > 0 && complete.cases(MyEffector[1]) &&
           MyEffector[1] != "none" & compoundToExtract != "inhibitor 1"){
            
            warning("When there is an effector present in the simulation, as is the case here, the Simcyp Consultancy report template recommends only showing the means. You may want to change figure_type to 'means only'.",
                    call. = FALSE)
            
            A <- ggplot(RibbonDF, aes(x = Time,
                                      y = mean, ymin = per5, ymax = per95, 
                                      linetype = Inhibitor, shape = Inhibitor,
                                      color = Inhibitor, fill = Inhibitor)) +
                geom_ribbon(alpha = AlphaToUse, color = NA) +
                geom_line(lwd = ifelse(is.na(line_width), 1, line_width)) +
                scale_shape_manual(values = obs_shape[1:2]) +
                scale_linetype_manual(values = line_type[1:2]) +
                scale_color_manual(values = line_color[1:2]) +
                scale_fill_manual(values = line_color[1:2])
            
            if(nrow(obs_data) > 0){
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + geom_point(data = obs_data, 
                                        aes(x = Time, y = Conc, color = Inhibitor,
                                            shape = Inhibitor, fill = Inhibitor),
                                        inherit.aes = FALSE, size = 2,
                                        stroke = 1, fill = NA)
                } else {
                    A <- A +
                        geom_point(data = obs_data, 
                                   aes(x = Time, y = Conc, color = Inhibitor,
                                       shape = Inhibitor, fill = Inhibitor),
                                   inherit.aes = FALSE, size = 2,
                                   alpha = 0.5, stroke = 1) +
                        scale_fill_manual(values = obs_color) +
                        # have to add geom_point 2x b/c alpha applies to both
                        # color (as in, the outline of the point) AND the fill
                        # of the point
                        geom_point(data = obs_data, 
                                   aes(x = Time, y = Conc, color = Inhibitor,
                                       shape = Inhibitor, fill = Inhibitor),
                                   inherit.aes = FALSE, size = 2,
                                   fill = NA, stroke = 1)
                }
            }
            
        } else {
            
            ## linear plot
            A <- ggplot(RibbonDF, aes(x = Time, y = mean, ymin = per5, ymax = per95)) +
                geom_ribbon(alpha = AlphaToUse, color = NA,
                            fill = line_color[1]) +
                geom_line(lwd = ifelse(is.na(line_width), 1, line_width),
                          linetype = line_type[1],
                          color = line_color[1])
            
            if(nrow(obs_data) > 0){
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + 
                        geom_point(data = obs_data, 
                                   aes(x = Time, y = Conc), inherit.aes = FALSE,
                                   size = 2, stroke = 1, shape = obs_shape[1])
                } else {
                    A <- A +
                        geom_point(data = obs_data,
                                   aes(x = Time, y = Conc), inherit.aes = FALSE,
                                   size = 2, fill = obs_color[1], alpha = 0.5,
                                   stroke = 1, shape = obs_shape[1]) +
                        geom_point(data = obs_data, 
                                   aes(x = Time, y = Conc), inherit.aes = FALSE,
                                   size = 2, fill = NA, shape = obs_shape[1], 
                                   stroke = 1)
                }
            }
        }
    }
    
    ## figure_type: Freddy --------------------------------------------------------------
    if(figure_type == "Freddy"){
        
        NumTrials <- length(unique(sim_data_trial$Trial))
        AlphaToUse <- ifelse(complete.cases(line_transparency),
                             line_transparency,
                             ifelse(NumTrials > 10, 0.05, 0.25))
        
        if(length(MyEffector) > 0 && complete.cases(MyEffector[1]) &&
           MyEffector[1] != "none" & compoundToExtract != "inhibitor 1"){
            
            warning("When there is an effector present in the simulation, as is the case here, the Simcyp Consultancy report template recommends only showing the means. You may want to change figure_type to 'means only'.",
                    call. = FALSE)
            
            ## linear plot
            A <- ggplot(data = sim_data_mean %>%
                            filter(Trial == MyMeanType),
                        aes(x = Time, y = Conc, group = Group,
                            linetype = Inhibitor, shape = Inhibitor,
                            color = Inhibitor, fill = Inhibitor)) +
                geom_line(lwd = ifelse(is.na(line_width), 1, line_width)) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial %in% c("per5", "per95")),
                          alpha = AlphaToUse, 
                          lwd = ifelse(is.na(line_width), 1, line_width)) +
                scale_shape_manual(values = obs_shape[1:2]) +
                scale_linetype_manual(values = line_type[1:2]) +
                scale_color_manual(values = line_color[1:2])
            
            if(nrow(obs_data) > 0){
                # When figure_type == "Freddy", I want the default to be
                # a blue-purple semi-transparent fill. However, I want
                # people to have the option to override that, so
                # setting obs_color to "none" will override the
                # "Freddy" default. -LS
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + geom_point(data = obs_data, size = 2,
                                        fill = NA, stroke = 1)
                } else {
                    # This is the situation when the user has
                    # requested a specific color for the Freddy figure
                    # type.
                    A <- A +
                        geom_point(data = obs_data, size = 2,
                                   alpha = 0.5, stroke = 1) +
                        scale_fill_manual(values = obs_color) +
                        # have to add geom_point 2x b/c alpha applies to both
                        # color (as in, the outline of the point) AND the fill
                        # of the point
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, stroke = 1)
                }
            }
            
        } else {
            
            ## linear plot
            A <- ggplot(sim_data_trial,
                        aes(x = Time, y = Conc, group = Trial)) +
                geom_line(alpha = AlphaToUse, 
                          lwd = ifelse(is.na(line_width), 1, line_width),
                          linetype = line_type[1],
                          color = line_color[1]) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial == MyMeanType),
                          lwd = ifelse(is.na(line_width), 1, line_width), linetype = line_type[1],
                          color = line_color[1]) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial %in% c("per5", "per95")),
                          linetype = line_type[2],
                          color = line_color[2])
            
            if(nrow(obs_data) > 0){
                # When figure_type == "Freddy", I want the default to be
                # a blue-purple semi-transparent fill. However, I want
                # people to have the option to override that, so
                # setting obs_color to "none" will override the
                # "Freddy" default. -LS
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + geom_point(data = obs_data, size = 2,
                                        fill = NA, stroke = 1,
                                        shape = obs_shape[1])
                } else {
                    # This is the situation when the user has
                    # requested a specific color for the Freddy figure
                    # type.
                    A <- A +
                        geom_point(data = obs_data, size = 2,
                                   fill = obs_color[1], alpha = 0.5,
                                   stroke = 1, shape = obs_shape[1]) +
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, stroke = 1,
                                   shape = obs_shape[1])
                }
            }
        }
    }
    
    ## figure_type: means only -----------------------------------------------------------
    if(figure_type == "means only"){
        
        if(length(MyEffector) > 0 && complete.cases(MyEffector[1]) &&
           MyEffector[1] != "none" & compoundToExtract != "inhibitor 1"){
            
            A <- ggplot(sim_data_mean %>%
                            filter(Trial == MyMeanType) %>%
                            mutate(Group = paste(Group, Trial)),
                        aes(x = Time, y = Conc, 
                            linetype = Inhibitor, shape = Inhibitor, 
                            color = Inhibitor, fill = Inhibitor)) +
                geom_line(lwd = ifelse(is.na(line_width), 1, line_width)) +
                scale_linetype_manual(values = line_type[1:2]) +
                scale_color_manual(values = line_color[1:2]) +
                scale_shape_manual(values = obs_shape[1:2])
            
            if(nrow(obs_data) > 0){
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <-  A + geom_point(data = obs_data, size = 2,
                                         stroke = 1, fill = NA)
                } else {
                    # Glitch when the user has supplied observed data
                    # with a different number of inhibitors than
                    # sim_data_trial, e.g., when the obs data came
                    # with the simulator output file. Addressing that.
                    if(length(unique(obs_data$Inhibitor)) == 1){
                        obs_color <- obs_color[1]
                    }
                    
                    A <- A +
                        geom_point(data = obs_data, size = 2,
                                   alpha = 0.5, stroke = 1) +
                        scale_fill_manual(values = obs_color) +
                        # have to add geom_point 2x b/c alpha applies to both
                        # color (as in, the outline of the point) AND the fill
                        # of the point
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, stroke = 1)
                }
            }
            
        } else {
            
            A <- ggplot(sim_data_mean %>%
                            filter(Trial == MyMeanType),
                        aes(x = Time, y = Conc)) +
                geom_line(lwd = ifelse(is.na(line_width), 1, line_width),
                          linetype = line_type[1],
                          color = line_color[1])
            
            if(nrow(obs_data) > 0){
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + geom_point(data = obs_data, size = 2,
                                        shape = obs_shape[1], stroke = 1, 
                                        fill = NA)
                } else {
                    
                    A <- A + geom_point(data = obs_data, size = 2,
                                        fill = obs_color[1], alpha = 0.5,
                                        shape = obs_shape[1], stroke = 1) +
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, shape = obs_shape[1], stroke = 1)
                }
            }
        }
    }
    
    
    # Applying aesthetics ------------------------------------------------
    ## Making linear graph -------------------------------------------------
    
    if(nrow(obs_data) == 0){
        A <- A + guides(shape = "none")
    }
    
    if(str_detect(figure_type, "ribbon")){
        # There's a known glitch w/ggplot2 with coord_cartesian and
        # geom_ribbon. Hacking around that.
        A <- A +
            scale_x_continuous(breaks = XBreaks, labels = XLabels,
                               limits = time_range_relative,
                               expand = expansion(
                                   mult = pad_x_num)) +
            scale_y_continuous(limits = c(ifelse(is.na(y_axis_limits_lin[1]), 
                                                 0, y_axis_limits_lin[1]),
                                          YmaxRnd), 
                               breaks = YBreaks,
                               labels = YLabels,
                               expand = expansion(mult = pad_y_num)) 
        
    } else {
        A <- A +
            coord_cartesian(xlim = time_range_relative, 
                            ylim = c(ifelse(is.na(y_axis_limits_lin[1]), 
                                            0, y_axis_limits_lin[1]),
                                     YmaxRnd)) +
            scale_x_continuous(breaks = XBreaks, labels = XLabels,
                               expand = expansion(
                                   mult = pad_x_num)) +
            scale_y_continuous(breaks = YBreaks,
                               labels = YLabels,
                               expand = expansion(mult = pad_y_num)) 
    }
    
    A <- A +
        labs(x = xlab, y = ylab,
             linetype = ifelse(complete.cases(legend_label),
                               legend_label, "Inhibitor"),
             shape = ifelse(complete.cases(legend_label),
                            legend_label, "Inhibitor"),
             color = ifelse(complete.cases(legend_label), 
                            legend_label, "Inhibitor"),
             fill = ifelse(complete.cases(legend_label), 
                           legend_label, "Inhibitor")) +
        theme(panel.background = element_rect(fill="white", color=NA),
              legend.key = element_rect(fill = "white"),
              axis.ticks = element_line(color = "black"),
              axis.text = element_text(color = "black"),
              axis.title = element_text(color = "black", face = "bold"),
              axis.line.x.bottom = element_line(color = "black"),
              axis.line.y.left = element_line(color = "black"))
    
    
    # If the user didn't want the legend or if the graph is of an effector,
    # remove legend.
    if(legend_position == "none" | compoundToExtract %in% c("inhibitor 1", "inhibitor 2", 
                                                            "inhibitor 1 metabolite")){
        A <- A + theme(legend.position = "none")
    } else {
        # Otherwise, make the legend a little wider to actually show the dashes
        A <- A + theme(legend.position = legend_position, 
                       legend.key.width = unit(2, "lines"))
    }
    
    ## Making semi-log graph ------------------------------------------------
    B <- suppressMessages(
        A + scale_y_log10(breaks = YLogBreaks,
                          labels = YLogLabels,
                          expand = expansion(mult = pad_y_num)) +
            # labels = function(.) format(., scientific = FALSE, drop0trailing = TRUE)) +
            coord_cartesian(xlim = time_range_relative, 
                            ylim = Ylim_log)
    )
    
    if(graph_labels){
        labels <- "AUTO"
    } else {
        labels <- NULL
    }
    
    # both plots together, aligned vertically
    if(compoundToExtract %in% c("inhibitor 1", "inhibitor 2", 
                                "inhibitor 1 metabolite")){
        AB <- suppressWarnings(
            ggpubr::ggarrange(A, B, ncol = 1, 
                              labels = labels,
                              align = "v")
        )
        
        ABhoriz <- suppressWarnings(
            ggpubr::ggarrange(A, B, ncol = 2, 
                              labels = labels,
                              align = "hv")
        )
        
    } else {
        # If the user didn't want the legend or if the graph is of Inhibitor1,
        # remove legend.
        if(legend_position == "none" | 
           compoundToExtract %in% c("inhibitor 1", "inhibitor 2", 
                                    "inhibitor 1 metabolite")){
            AB <- suppressWarnings(
                ggpubr::ggarrange(A, B, ncol = 1, 
                                  labels = labels,
                                  legend = "none", align = "hv"))
            
            ABhoriz <- suppressWarnings(
                ggpubr::ggarrange(A, B, ncol = 2,  
                                  labels = labels,
                                  legend = "none", align = "hv"))
        } else {
            AB <- suppressWarnings(
                ggpubr::ggarrange(A, B, ncol = 1,  
                                  labels = labels,
                                  common.legend = TRUE, legend = legend_position,
                                  align = "hv"))
            
            ABhoriz <- suppressWarnings(
                ggpubr::ggarrange(A, B, ncol = 2,  
                                  labels = labels,
                                  common.legend = TRUE, legend = legend_position,
                                  align = "hv"))
        }
    }
    
    Out <- switch(linear_or_log, 
                  "linear" = A,
                  "semi-log" = B,
                  "log" = B,
                  "both" = AB, 
                  "both vertical" = AB,
                  "both horizontal" = ABhoriz)
    
    if(length(Out) == 1){
        Out <- Out[[1]]
    }
    
    if(complete.cases(save_graph)){
        FileName <- save_graph
        if(str_detect(FileName, "\\.")){
            # Making sure they've got a good extension
            Ext <- sub("\\.", "", str_extract(FileName, "\\..*"))
            FileName <- sub(paste0(".", Ext), "", FileName)
            Ext <- ifelse(Ext %in% c("eps", "ps", "jpeg", "tiff",
                                     "png", "bmp", "svg", "jpg", "docx"), 
                          Ext, "png")
            FileName <- paste0(FileName, ".", Ext)
        } else {
            FileName <- paste0(FileName, ".png")
            Ext <- "png"
        }
        
        if(Ext == "docx"){
            
            # This is when they want a Word file as output
            OutPath <- dirname(FileName)
            
            if(OutPath == "."){
                OutPath <- getwd()
            }
            
            # Check for whether they're trying to save on SharePoint, which DOES
            # NOT WORK. If they're trying to save to SharePoint, instead, save
            # to their Documents folder.
            
            # Side regex note: The myriad \ in the "sub" call are necessary b/c
            # \ is an escape character, and often the SharePoint and Large File
            # Store directory paths start with \\\\.
            if(str_detect(sub("\\\\\\\\", "//", OutPath), SimcypDir$SharePtDir)){
                
            OutPath <- paste0("C:/Users/", Sys.info()[["user"]], 
                              "/Documents")
            warning(paste0("You have attempted to use this function to save a Word file to SharePoint, and Microsoft permissions do not allow this. We will attempt to save the ouptut to your Documents folder, which we think should be ", 
                           OutPath,
                           ". Please copy the output to the folder you originally requested or try saving locally or on the Large File Store."), 
                    call. = FALSE)
            }
            
            LFSPath <- str_detect(sub("\\\\\\\\", "//", OutPath), SimcypDir$LgFileDir)
            
            if(LFSPath){
                # Create a temporary directory in the user's AppData/Local/Temp
                # folder.
                TempDir <- tempdir()
                
                # Upon exiting this function, delete that temporary directory.
                on.exit(unlink(TempDir))
                
            }
            
            FileName <- basename(FileName)
            
            if(EnzPlot){
                rmarkdown::render(system.file("rmarkdown/templates/enzyme-abundance-plot/skeleton/skeleton.Rmd",
                                              package="SimcypConsultancy"), 
                                  output_dir = switch(as.character(LFSPath), 
                                                      "TRUE" = TempDir,
                                                      "FALSE" = OutPath),
                                  output_file = FileName, 
                                  quiet = TRUE)
                
                if(LFSPath){
                    file.copy(file.path(TempDir, FileName), OutPath, overwrite = TRUE)
                }
                
            } else {
                
                rmarkdown::render(system.file("rmarkdown/templates/concentration-time-plots/skeleton/skeleton.Rmd",
                                              package="SimcypConsultancy"), 
                                  output_dir = switch(as.character(LFSPath), 
                                                      "TRUE" = TempDir,
                                                      "FALSE" = OutPath),
                                  output_file = FileName, 
                                  quiet = TRUE)
                # Note: The "system.file" part of the call means "go to where the
                # package is installed, search for the file listed, and return its
                # full path.
                
                if(LFSPath){
                    file.copy(file.path(TempDir, FileName), OutPath, overwrite = TRUE)
                }
            }
            
        } else {
            # This is when they want any kind of graphical file format.
            if(linear_or_log %in% c("both", "both vertical")){
                ggsave(FileName, height = fig_height, width = fig_width, dpi = 600,
                       plot = AB)
            }
            
            if(linear_or_log == "both horizontal"){
                ggsave(FileName, height = fig_height, width = fig_width, dpi = 600, 
                       plot = ABhoriz)
            }
            
            if(linear_or_log == "linear"){
                ggsave(FileName, height = fig_height, width = fig_width, dpi = 600, 
                       plot = A)
            }
            
            if(str_detect(linear_or_log, "log")){
                ggsave(FileName, height = fig_height, width = fig_width, dpi = 600, 
                       plot = B)
            }
        }
    }
    
    return(Out)
}




