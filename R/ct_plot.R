#' Concentration-time plots to match Consultancy template
#'
#' Using observed and simulated concentration-time data, make
#' publication-quality graphs that match the consultancy template formatting
#' instructions. We've tried to include a fair number of options here for
#' flexibility, but many of the function arguments are optional; most of the
#' time, you'll get decent-looking graphs while only setting a minimal number of
#' arguments. If you want to plot enzyme abundance data, please see
#' \code{\link{enz_plot}}. \strong{A few notes:} \enumerate{\item{Not all
#' substrate metabolites, inhibitors, or inhibitor metabolites are available in
#' all tissues.} \item{When observed data are included in a simulator output
#' file, because the simulator output does not explicitly say whether those
#' observed data were in the presence of an effector, this function cannot tell
#' the difference and will thus assume all observed data included in the
#' simulator output were for the substrate in the \emph{absence} of any
#' effector. It will further assume that the compound the observed data is for
#' is the same as \code{compoundToExtract}. If you want to specify which
#' compound the observed data were for and/or whether any effectors were
#' present, please supply an observed data file to the argument
#' \code{obs_data_file}.}}
#'
#' @param sim_obs_dataframe the input concentration-time data generated by
#'   running the function \code{\link{extractConcTime}}
#' @param concType_ADAM ADAM model only: For ADAM model output, multiple types
#'   of data are available. Which of those concentration types do you want to
#'   show? Options are whatever were available for that tissue, which could be
#'   "solid compound", "free compound in lumen", "Heff", "absorption rate",
#'   "unreleased substrate in faeces", "unreleased inhibitor in faeces",
#'   "dissolved compound", or "luminal CLint of compound". Default is "free
#'   compound in lumen".
#' @param figure_type type of figure to plot. Options are:
#'
#'   \describe{
#'
#'   \item{trial means}{plots a black line for the mean data, gray lines for the
#'   mean of each trial of simulated data, and open circles for the observed
#'   data. If an effector was present, gray dashed lines indicate the mean of
#'   each trial of simulated data in the presence of the effector.}
#'
#'   \item{percentiles}{plots a black line for the mean data, gray lines for the
#'   5th and 95th percentiles of the simulated data, and open circles for the
#'   observed data}
#'
#'   \item{means only}{plots a black line for the mean data and, if an effector
#'   was modeled, a dashed line for the concentration-time data with Inhibitor
#'   1.}
#'
#'   \item{Freddy}{Freddy's favorite style of plot with trial means in light
#'   gray, the overall mean in thicker black, the 5th and 95th percentiles in
#'   dashed lines, and the observed data in semi-transparent purple-blue. Graphs
#'   with an effector present lose the trial means, and the percentiles switch
#'   to solid, gray lines. \strong{An editorial comment:} While this does not
#'   align with the officially sanctioned template at this time, this looks
#'   \emph{sharp}, makes it easy to see the defining characteristics of the
#'   data, and I recommend checking it out. If the color is too much for you but
#'   you like the rest, try setting \code{obs_color = "none"}. -LS}}
#'
#' @param time_range time range to show relative to the start of the simulation.
#'   Options: \describe{
#'
#'   \item{NA}{entire time range of data}
#'
#'   \item{a start time and end time in hours}{only data in that time range,
#'   e.g. \code{c(24, 48)}}
#'
#'   \item{"first dose"}{only the time range of the first dose}
#'
#'   \item{"last dose"}{only the time range of the last dose}
#'
#'   \item{"penultimate dose"}{only the time range of the 2nd-to-last dose,
#'   which can be useful for BID data where the end of the simulation extended
#'   past the dosing interval or data when the substrate was dosed BID and the
#'   effector was dosed QD}
#'
#'   \item{a specific dose number with "dose" or "doses" as the prefix}{the time
#'   range encompassing the requested doses, e.g., "dose 3" for the 3rd dose or
#'   "doses 1 to 4" for doses 1 to 4}}
#'
#' @param t0 What event should be used for time zero? Options are: "simulation
#'   start" (default), "substrate dose 1", "inhibitor 1 dose 1", "substrate last
#'   dose", "inhibitor 1 last dose", "substrate penultimate dose", or "inhibitor
#'   1 penultimate dose". \emph{This does not change which data are included in
#'   the graph;} instead, this determines whether the x axis numbers are offset
#'   so that, e.g., the last dose is administered at time 0.
#'
#' @param adjust_obs_time TRUE or FALSE: Adjust the time listed in the observed
#'   data file to match the last dose administered? This only applies to
#'   multiple-dosing regimens. If TRUE, the graph will show the observed data
#'   overlaid with the simulated data such that the dose in the observed data
#'   was administered at the same time as the last dose in the simulated data.
#'   If FALSE, the observed data will start at whatever times are listed in the
#'   Excel file.
#' @param pad_x_axis Optionally add a smidge of padding to the left side of the
#'   x axis. If left as FALSE, the y axis will be placed right at the beginning
#'   of your time range. If set to TRUE, there will be a little bit of space
#'   between the y axis and the start of your time range. NOTE: We could allow
#'   users to specify exactly how much padding and on which sides of the x axis
#'   if there's interest from users. -LS
#' @param x_axis_interval Set the x-axis major tick-mark interval. Acceptable
#'   input: any number or leave as NA to accept default values.
#'
#' @param y_axis_limits_lin Optionally set the Y axis limits for the linear
#'   plot, e.g., \code{c(10, 1000)}. If left as NA, the Y axis limits for the
#'   linear plot will be automatically selected.
#' @param y_axis_limits_log Optionally set the Y axis limits for the semi-log
#'   plot, e.g., \code{c(10, 1000)}. Values will be rounded down and up,
#'   respectively, to the nearest order of magnitude. If left as NA, the Y axis
#'   limits for the semi-log plot will be automatically selected.
#'
#' @param obs_data_option Set options for how to view observed data. Options
#'   are:
#'
#'   \describe{
#'
#'   \item{means only}{show only a single point at the arithmetic mean value for
#'   each time point}
#'
#'   \item{geometric means only}{show a single point at the geometric mean}
#'
#'   \item{all}{show all the individual data (equivalently, leave
#'   \code{obs_data_option} as NA)}
#'
#'   \item{mean bars}{show a point at the arithmetic mean for each time point
#'   and error bars for the arithmetic standard deviation}}
#'
#' @param obs_color If you would like the observed data points to be in color,
#'   either list a specific color or set this to "default". Points will be
#'   displayed in semi-transparent blue-purple for "default" and the
#'   semi-transparent version of whatever other color you list otherwise.
#'   Setting this to "none" will make sure that the symbols are black outlines
#'   only with no fill. Hex color codes are also ok to use.
#' @param obs_shape Optionally specify what shapes are used to depict observed
#'   data for 1. the substrate drug alone and 2. the substrate drug in the
#'   presence of an effector. Input should look like this, for example:
#'   \code{c(1, 2)} to get an open circle and an open triangle. To see all the
#'   possible shapes and what number corresponds to which shape, see
#'   \url{https://r-graphics.org/recipe-scatter-shapes} (there's a graph around
#'   the middle of that page). If left as NA, substrate alone will be an open
#'   circle and substrate + inhibitor 1 will be an open triangle.
#'
#' @param line_transparency Optionally specify the transparency for the trial
#'   mean or percentile lines. Acceptable values are from 0 (fully transparent,
#'   so no line at all) to 1 (completely opaque or black). If left as NA, this
#'   value will be automatically determined.
#' @param line_type Optionally specify what types of lines are used to depict 1.
#'   the substrate drug alone and 2. the substrate drug in the presence of an
#'   effector (when applicable). Input should look like this, for example:
#'   \code{c("solid", "dashed")} to get a solid line for the substrate drug and
#'   a dashed line for inhibitor 1. To see all possible \code{line_type}
#'   options: \code{ggpubr::show_line_types()}. If left as NA, substrate alone
#'   will be a solid line and substrate + inhibitor 1 will be a dashed line. If
#'   \code{figure_type} is "Freddy" and there's no effector present, which is a
#'   slightly different scenario than the other graph types, the 1st line type
#'   specified will be for the mean simulated concentration and the trial means,
#'   and the 2nd line type specified will be for the 5th and 95th percentiles.
#' @param line_color Optionally specify what colors to use for the lines.
#'   Acceptable input for, e.g., the substrate alone to be blue and the
#'   substrate + Inhibitor 1 to be red: \code{c("blue", "red")}. If left as NA,
#'   lines will be black or gray. Hex color codes are also ok to use.
#' @param line_width Optionally specify how thick to make the lines. Acceptable
#'   input is a number; the default is 1 for most lines and 0.8 for some, to
#'   give you an idea of where to start.
#' @param legend_label Optionally indicate on the legend whether the effector is
#'   an inhibitor,inducer, activator, or suppressor. Input will be used as the
#'   label in the legend for the line style and the shape. If left as NA when a
#'   legend is included and an effector is present, the label in the legend will
#'   be "Inhibitor 1".
#' @param prettify_effector_name Optionally make the Inhibitor 1 name prettier
#'   in the legend. This was designed for simulations where Inhibitor 1 is one
#'   of the standard options for the simulator, and leaving
#'   \code{prettify_effector_name = TRUE} will make the name of Inhibitor 1 be
#'   something more human readable. For example, "SV-Rifampicin-MD" will become
#'   "rifampicin", and "Sim-Ketoconazole-200 mg BID" will become "ketoconazole".
#'   Set it to the name you'd prefer to see in your legend if you would like
#'   something different.
#'
#' @param return_data TRUE or FALSE: Return the data used in the graphs? If
#'   TRUE, this will return a named list of: \describe{ \item{Graphs}{the set of
#'   graphs} \item{Data}{a data.frame of the concentration-time data used in the
#'   set of graphs} }
#' @param return_indiv_graphs TRUE or FALSE: Return each of the two individual
#'   graphs? This can be useful if you want to modify the graphs further or only
#'   use one, etc.
#' @param sim_data_file HISTORICAL BACK-COMPATIBILITY PURPOSES ONLY: name of the
#'   Excel file containing the simulated concentration-time data
#' @param obs_data_file HISTORICAL BACK-COMPATIBILITY PURPOSES ONLY: name of the
#'   Excel file containing the observed concentration-time data. If the observed
#'   data you want to plot were already included in the Excel output from the
#'   simulator, leave this as NA. Otherwise, this is the file that it is ready
#'   to be converted to an XML file, not the file that contains only the
#'   digitized time and concentration data.
#' @param obs_inhibitor_data_file HISTORICAL BACK-COMPATIBILITY PURPOSES ONLY:
#'   name of the Excel file containing the observed concentration-time data in
#'   the presence of an effector (labeled "Inhibitor 1" in the simulator). This
#'   is the file that is ready to be converted to an XML file. If your Inhibitor
#'   1 data were already included in \code{obs_data_file}, leave this as NA.
#' @param tissue HISTORICAL BACK-COMPATIBILITY PURPOSES ONLY: the tissue to
#'   plot. Default is plasma for typical plasma concentration-time data. Other
#'   tissues are acceptable, e.g., "lung", "brain", etc., as long as the tissue
#'   is one of the options included in "Sheet Options", "Tissues" in the
#'   simulator.
#' @param compoundToExtract HISTORICAL BACK-COMPATIBILITY PURPOSES ONLY: For
#'   which compound do you want to extract concentration-time data? Options are
#'   "substrate" (default), "primary metabolite 1", "secondary metabolite", or
#'   "inhibitor 1" (this actually can be an inducer, activator, suppressor, or
#'   inhibitor, but it's labeled as "Inhibitor 1" in the simulator).
#'
#' @return Depending on the options selected, returns either a set of graphs or
#'   a named list of the set of the two graphs together ("Graphs" in the
#'   output), the individual graphs ("Linear graph" and "Semi-log graph"),
#'   and/or the data used for creating the graphs ("Data").
#' @import tidyverse
#' @export
#'
#' @examples
#' # # Normal syntax with a fake file:
#' # sim_data_file <- "../Example simulator output.xlsx"
#' # obs_data_file <- "../fig1-242-06-001-MD - for XML conversion.xlsx"
#'
#' # However, since we can't load an Excel file as an example, here are
#' # some data to play with:
#' data(LMVct)
#'
#' ct_plot(sim_obs_dataframe = LMVct)
#' ct_plot(sim_obs_dataframe = LMVct, figure_type = "percentiles")
#' ct_plot(sim_obs_dataframe = LMVct, return_data = TRUE)
#' ct_plot(sim_obs_dataframe = LMVct, return_indiv_graphs = TRUE)
#'
#' # Perhaps you don't want to show *all* the data but instead want to
#' # limit the time interval that is graphed. Use \code{time_range} here:
#' ct_plot(sim_data_file = "../Example simulator output MD.xlsx",
#'         obs_data_file = "../fig1-242-06-001-SD - for XML conversion.xlsx",
#'         adjust_obs_time = FALSE, time_range = c(0, 24))
#'
#' # Or you can let it automatically calculate the time frame
#' # for a given set of doses
#' ct_plot(sim_obs_dataframe = LMVct
#'         time_range = "first dose")
#' ct_plot(sim_obs_dataframe = LMVct,
#'         time_range = "last dose")
#'
#' # The default graph may be too busy when Inhibitor 1 is present,
#' # so you may want to consider only plotting means as an alternative:
#' ct_plot(sim_obs_dataframe = LMVct,
#'         figure_type = "means only")
#'
#' # Add some further options for the look of your graph -- especially useful
#' # if the default settings are clipping your data.
#' ct_plot(sim_obs_dataframe = LMVct,
#'         obs_data_option = "mean bars",
#'         obs_color = "red",
#'         line_color = "blue",
#'         y_axis_limits_log = c(1e-05, 0.1),
#'         pad_x_axis = TRUE,
#'         include_legend = TRUE,
#'         legend_label = "Inhibitor")

ct_plot <- function(sim_obs_dataframe = NA,
                    figure_type = "trial means",
                    concType_ADAM = "free compound in lumen",
                    time_range = NA,
                    x_axis_interval = NA,
                    pad_x_axis = FALSE,
                    adjust_obs_time = FALSE,
                    t0 = "simulation start",
                    y_axis_limits_lin = NA,
                    y_axis_limits_log = NA,
                    obs_data_option = NA,
                    obs_color = NA,
                    obs_shape = NA,
                    line_type = NA,
                    line_transparency = NA,
                    line_color = NA,
                    line_width = NA,
                    include_legend = FALSE,
                    legend_label = NA,
                    prettify_effector_name = TRUE,
                    return_data = FALSE,
                    return_indiv_graphs = FALSE,
                    sim_data_file = NA,
                    obs_data_file = NA,
                    obs_inhibitor_data_file = NA, 
                    tissue = "plasma",
                    compoundToExtract = "substrate"){
    
    # Error catching
    if(length(figure_type) != 1 |
       figure_type %in% c("trial means", "percentiles", "trial percentiles",
                          "Freddy", "means only", "overlay") == FALSE){
        stop("The only acceptable options for figure_type are 'trial means', 'percentiles', 'means only', or 'Freddy'.")
    }
    
    if(all(complete.cases(time_range)) && class(time_range) == "numeric" &
       length(time_range) != 2){
        stop("You must enter a start and stop time for 'time_range', e.g., 'c(0, 24)' or enter 'last dose' to plot only the time range for the last dose.")
    }
    
    if(all(complete.cases(time_range)) && class(time_range) == "numeric" &
       time_range[1] >= time_range[2]){
        stop("The 1st value for 'time_range' must be less than the 2nd value.")
    }
    
    if(all(complete.cases(time_range)) && class(time_range) == "character" &
       length(time_range != 1)){
        time_range <- time_range[1]
    }
    
    if(all(complete.cases(time_range)) && class(time_range) == "character" &
       !any(time_range %in% c("last dose", "first dose", "penultimate dose")) &
       !str_detect(tolower(time_range), "^dose")){
        stop("time_range must be 'first dose', 'last dose', 'penultimate dose', dose number(s) (this option must start with 'dose'), or a numeric time range, e.g., c(12, 24).")
    }
    
    if(complete.cases(obs_data_option) &&
       obs_data_option %in% c("means only", "geometric means only", "all",
                              "mean bars") == FALSE){
        stop("The value for obs_data_option must be one of 'means only', 'geometric means only', 'all', or 'mean bars'.")
    }
    
    t0 <- tolower(t0)
    t0_opts <- c("simulation start", "substrate dose 1", "inhibitor 1 dose 1",
                 "substrate last dose", "inhibitor 1 last dose",
                 "substrate penultimate dose", "inhibitor 1 penultimate dose")
    if(t0 %in% t0_opts == FALSE){
        stop(paste0("t0 must be set to ",
                    sub("and", "or", str_comma(t0_opts)), "."))
    }
    
    # Extract the data to plot
    if(is.data.frame(sim_obs_dataframe)){
        Data <- sim_obs_dataframe
        
        # if(unique(sim_obs_dataframe$Tissue) %in% tissue == FALSE){
        #     warning(paste0("The tissue requested (or the default if a specific one was not requested) was ",
        #                    tissue,
        #                    ", but this tissue was not included in the supplied data.frame. The tissue graphed will be the tissue in the supplied data.frame: ",
        #                    unique(sim_obs_dataframe$Tissue), "."))
        #     
        #     tissue <- unique(sim_obs_dataframe$Tissue)
        # }
        # 
        # if(unique(sim_obs_dataframe$CompoundID) %in% compoundToExtract == FALSE){
        #     warning(paste0("The compound requested (or the default if a specific one was not requested) was the ",
        #                    compoundToExtract,
        #                    ", but this compound was not included in the supplied data.frame. The compound graphed will be the compound in the supplied data.frame, which was the ",
        #                    unique(sim_obs_dataframe$CompoundID), "."))
        #     
        #     compoundToExtract <- unique(sim_obs_dataframe$CompoundID)
        # }
        
    } else {
        Data <- extractConcTime(sim_data_file = sim_data_file,
                                obs_data_file = obs_data_file,
                                tissue = tissue,
                                compoundToExtract = compoundToExtract,
                                obs_inhibitor_data_file = obs_inhibitor_data_file,
                                adjust_obs_time = adjust_obs_time)
    }
    
    # If user supplied sim_obs_dataframe, then set tissue to whatever tissue was
    # included and set compoundToExtract to whatever compound was included.
    tissue <- unique(Data$Tissue)
    compoundToExtract <- unique(Data$CompoundID)
    
    # Noting whether the tissue was from an ADAM model
    ADAM <- tissue %in% c("stomach", "duodenum", "jejunum I", "jejunum II", "ileum I",
                          "ileum II", "ileum III", "ileum IV", "colon", "faeces")
    
    # If the tissue was an ADAM tissue, only include the concType_ADAM they requested. 
    if(ADAM){
        
        if(length(concType_ADAM) > 1){
            stop("You can only enter one option for the concentration type for ADAM-model tissues. Please set concType_ADAM to one of 'solid compound', 'free compound in lumen', 'Heff', 'absorption rate', 'unreleased substrate in faeces', 'unreleased inhibitor in faeces', 'dissolved compound', or 'luminal CLint of compound'")
        }
        
        if(concType_ADAM %in% c("solid compound", "free compound in lumen",
                                "Heff", "absorption rate", 
                                "unreleased substrate in faeces",
                                "unreleased inhibitor in faeces",
                                "dissolved compound",
                                "luminal CLint of compound") == FALSE){
            stop(paste0("The concentration type you requested, ", concType_ADAM,
                        ", is not one of the options. Please set this value to one of 'solid compound', 'free compound in lumen', 'Heff', 'absorption rate', 'unreleased substrate in faeces', 'unreleased inhibitor in faeces', 'dissolved compound', or 'luminal CLint of compound'"))
        }
        
        Data <- Data %>% filter(ConcType == concType_ADAM)
    }
    
    # You can't graph trial means if you didn't extract the individual data
    # (this is one of the rare instances where we DO calculate things rather
    # than pulling directly from the simulator output), so issuing an error if
    # that's the case.
    if(figure_type %in% c("trial means", "Freddy") &
       suppressWarnings(length(sort(as.numeric(
           as.character(unique(Data$Trial)))))) == 0){
        warning("The figure type selected requires the calculation of trial means, but the individual data were not supplied. Only the overall aggregate data will be displayed.")
    }
    
    TimeUnits <- sort(unique(Data$Time_units))
    
    # Check whether the user is plotting enzyme abundance
    EnzPlot <- names(Data)[1] == "Enzyme"
    if(EnzPlot){
        ObsConcUnits <- "Relative abundance"
        Data <- Data %>% rename(Conc = Abundance) %>%
            mutate(Simulated = TRUE,
                   Compound = Enzyme,
                   Inhibitor = ifelse(EffectorPresent,
                                      "inhibitor 1", "none"))
    } else {
        ObsConcUnits <- sort(unique(Data$Conc_units))
    }
    
    
    # A little more error catching
    if(all(complete.cases(time_range) & class(time_range) == "numeric") &
       (any(time_range < min(Data$Time[Data$Simulated == TRUE])) |
        any(time_range > max(Data$Time[Data$Simulated == TRUE])))){
        stop(paste0(
            "Both the values entered for the time range must be within the range of time simulated. The range of time in your simulation was ",
            min(Data$Time[Data$Simulated == TRUE]), " to ",
            max(Data$Time[Data$Simulated == TRUE]), " ", TimeUnits, "."))
    }
    
    
    # Setting x axis (time) ------------------------------------------------
    # Adjusting graph labels as appropriate for the observed data
    xlab <- switch(TimeUnits,
                   "hours" = "Time (h)",
                   "minutes" = "Time (min)")
    
    ylab <- switch(ObsConcUnits,
                   "µg/mL" = expression(Concentration~"("*mu*g/mL*")"),
                   "ng/mL" = "Concentration (ng/mL)",
                   "ng/L" = "Concentration (ng/L)",
                   "µM" = expression(Concentration~"("*mu*M*")"),
                   "nM" = "Concentration (nM)",
                   "mg" = "Concentration (mg)",
                   "mg/L" = expression(Concentration~"("*mu*g/mL*")"),
                   "mL" = "mL",
                   "PD response" = "PD response",
                   "Relative abundance" = "Relative abundance")
    
    # Setting the breaks for the x axis
    tlast <- ifelse(all(complete.cases(time_range)) &
                        length(time_range) == 2,
                    time_range[2], max(Data$Time))
    
    time_range_input <- time_range
    
    if(class(time_range_input) == "character" | t0 != "simulation start"){
        
        if(time_range == "dose 1"){
            time_range = "first dose"
        }
        
        SingleDose <- Data %>% filter(DoseNum > 0) %>% pull(DoseNum) %>%
            unique()
        SingleDose <- length(SingleDose) == 1 && SingleDose == 1
        
        if(SingleDose){
            DoseTimes <- data.frame(
                FirstDoseEnd = max(Data$Time[Data$CompoundID == compoundToExtract]),
                PenultDoseStart = floor(min(Data$Time[Data$DoseNum == 1 &
                                                          Data$CompoundID == compoundToExtract])),
                LastDoseStart = floor(min(Data$Time[Data$DoseNum == 1 &
                                                        Data$CompoundID == compoundToExtract])))
        } else {
            DoseTimes1 <- Data %>% 
                filter(DoseNum > 0 & CompoundID == compoundToExtract) %>%
                group_by(DoseNum) %>%
                summarize(t0 = round(min(Time)), # Is it safe to round this to the nearest unit? Probably ok but may need to adjust this later.
                          tlast = round(max(Time))) %>% 
                ungroup()
            
            MaxNumDoses <- max(Data$DoseNum[Data$CompoundID == compoundToExtract])
            
            DoseTimes <- 
                data.frame(FirstDoseEnd = DoseTimes1 %>% 
                               filter(DoseNum == 1) %>% pull(tlast),
                           PenultDoseStart = DoseTimes1 %>% 
                               filter(DoseNum == MaxNumDoses - 1) %>% pull(t0),
                           LastDoseStart = DoseTimes1 %>% 
                               filter(DoseNum == MaxNumDoses) %>% pull(t0))
        }
        
        if(SingleDose & time_range_input %in% c("last dose", "penultimate dose")){
            warning(paste0("You requested the ", time_range_input,
                           ", but the substrate was administered as a single dose. The graph x axis will cover the substrate administration time until the end of the simulation."))
        }
        
        if(time_range_input == "first dose"){
            time_range <- c(0, DoseTimes$FirstDoseEnd)
        }
        
        if(time_range_input == "penultimate dose"){
            if(SingleDose){
                time_range <-
                    c(DoseTimes$LastDoseStart, max(Data$Time))
            } else {
                time_range <-
                    DoseTimes %>% ungroup() %>%
                    select(PenultDoseStart, LastDoseStart) %>%
                    t() %>% as.numeric()
            }
        }
        
        if(time_range_input == "last dose"){
            time_range <- c(DoseTimes$LastDoseStart, max(Data$Time))
        }
        
        if(str_detect(tolower(time_range_input), "^dose")){
            
            if(str_detect(time_range_input, "to")){
                
                DoseNumToPull <- as.numeric(
                    str_trim(str_split(
                        gsub("dose(s)?", "", time_range_input), "to")[[1]]))
                
            } else {
                
                DoseNumToPull <- as.numeric(
                    str_trim(gsub("dose(s)?", "", time_range_input)))
                
            }
            
            time_range <- Data %>% 
                filter(DoseNum %in% DoseNumToPull &
                           CompoundID == compoundToExtract) %>% 
                summarize(Min = min(Time), 
                          Max = max(Time)) %>% 
                t() %>% as.numeric()
        }
    }
    
    # Setting the x axis intervals using tlast doesn't work well if the time
    # range starts at something other than 0 or ends somewhere other than the
    # max time, so adjusting for that situation.
    if(all(complete.cases(time_range)) &
       (time_range[1] != 0 | time_range[2] != max(Data$Time))){
        
        tlast <- time_range[2] - time_range[1]
        LastDoseTime <- time_range[1]
        
    }
    
    # Setting the time range if it's not already set since we use it later.
    if(is.na(time_range_input[1])){
        time_range <- range(Data$Time, na.rm = T)
    }
    
    # If tlast is just a smidge over one of the possible breaks I've set, it
    # goes to the next one and doesn't look as nice on the graph. Rounding
    # tlast down to the nearest 4 for hours and nearest 15 for minutes.
    tlast <- ifelse(TimeUnits == "hours",
                    round_down_unit(tlast, 4),
                    round_down_unit(tlast, 15))
    
    if(TimeUnits == "hours"){
        
        PossBreaks <- data.frame(
            Tlast = c(12, 24, 48, 96, 168, 336, 360, 504, 672, Inf),
            BreaksToUse = c("12hr", "24hr", "48hr", "96hr", "1wk", "2wk",
                            "15d", "3wk", "4wk", "4wkplus"))
        
        BreaksToUse <- PossBreaks %>% filter(Tlast >= tlast) %>%
            slice(which.min(Tlast)) %>% pull(BreaksToUse)
        
        BreaksToUse <- ifelse(complete.cases(x_axis_interval),
                              "UserDefined", BreaksToUse)
        
        XBreaks <- switch(BreaksToUse,
                          "12hr" = seq(0, 12, 1),
                          "24hr" = seq(0, 24, 2),
                          "48hr" = seq(0, 48, 4),
                          "96hr" = seq(0, 96, 6),
                          "1wk" = seq(0, 168, 12),
                          "2wk" = seq(0, 336, 24),
                          "15d" = seq(0, 360, 24),
                          "3wk" = seq(0, 504, 36),
                          "4wk" = seq(0, 672, 48),
                          "4wkplus" = round_up_nice(seq(0, tlast,
                                                        length.out = 12)),
                          "UserDefined" = seq(0, max(Data$Time, na.rm = T),
                                              x_axis_interval/2))
        
    }
    
    if(TimeUnits == "minutes"){
        PossBreaks <- data.frame(Tlast = c(60, 240, 480, 720, 1440, Inf),
                                 BreaksToUse = c("1hr", "4hr",
                                                 "8hr", "12hr",
                                                 "24hr", "24hrplus"))
        
        BreaksToUse <- PossBreaks %>% filter(Tlast >= tlast) %>%
            slice(which.min(Tlast)) %>% pull(BreaksToUse)
        
        BreaksToUse <- ifelse(complete.cases(x_axis_interval),
                              "UserDefined", BreaksToUse)
        
        XBreaks <- switch(BreaksToUse,
                          "1hr" = seq(0, 60, 7.5),
                          "4hr" = seq(0, 240, 15),
                          "8hr" = seq(0, 480, 30),
                          "12hr" = seq(0, 720, 60),
                          "24hr" = seq(0, 1440, 120),
                          "24hrplus" = round_up_nice(seq(0, tlast,
                                                         length.out = 12)),
                          "UserDefined" = seq(0, max(Data$Time, na.rm = T),
                                              x_axis_interval/2))
    }
    
    # Adjusting the breaks when time_range[1] isn't 0
    if(all(complete.cases(time_range)) & time_range[1] != 0){
        XBreaks <- XBreaks + LastDoseTime
    }
    
    # If t0 isn't "simulation start", need to adjust x axis.
    if(t0 != "simulation start"){
        t0_num <- switch(
            t0,
            "substrate dose 1" = difftime_sim(Deets$SimStartDayTime,
                                              Deets$StartDayTime_sub),
            "inhibitor 1 dose 1" = difftime_sim(Deets$SimStartDayTime,
                                                Deets$StartDayTime_inhib),
            "substrate last dose" =
                ifelse(StartLastDose["Sub"] == max(Data$Time),
                       StartLastDose["Sub"] - DoseInt["Sub"],
                       StartLastDose["Sub"]),
            "inhibitor 1 last dose" =
                ifelse(StartLastDose["Inhib"] == max(Data$Time),
                       StartLastDose["Inhib"] - DoseInt["Inhib"],
                       StartLastDose["Inhib"]),
            "substrate penultimate dose" =
                ifelse(StartLastDose["Sub"] == max(Data$Time),
                       StartLastDose["Sub"] - 2*DoseInt["Sub"],
                       StartLastDose["Sub"] - DoseInt["Sub"]),
            "inhibitor 1 penultimate dose"  =
                ifelse(StartLastDose["Inhib"] == max(Data$Time),
                       StartLastDose["Inhib"] - 2*DoseInt["Inhib"],
                       StartLastDose["Inhib"] - DoseInt["Inhib"]))
        Data$Time_orig <- Data$Time
        Data$Time <- Data$Time - t0_num
        XBreaks <- XBreaks - t0_num
    } else {
        Data$Time_orig <- Data$Time
    }
    
    XLabels <- XBreaks
    XLabels[seq(2,length(XLabels),2)] <- ""
    XLabels[which(XBreaks == 0)] <- "0"
    
    # Dealing with possible inhibitor 1 data ---------------------------------
    # Adding a grouping variable to data and also making the inhibitor 1 name
    # prettier for the graphs.
    MyEffector <- unique(Data$Inhibitor) %>% as.character()
    MyEffector <- MyEffector[!MyEffector == "none"]
    
    if(length(MyEffector) > 0 && complete.cases(MyEffector)){
        
        Data <- Data %>%
            mutate(CompoundIsEffector = Compound == MyEffector,
                   Inhibitor = as.character(ifelse(is.na(Inhibitor),
                                                   "none", Inhibitor)))
        
        if(class(prettify_effector_name) == "logical" &&
           prettify_effector_name){
            MyEffector <-
                tolower(gsub(
                    "SV-|Sim-|_EC|_SR|-MD|-SD|-[1-9]00 mg [QMSTBI]{1,2}D|_Fasted Soln|_Fed Capsule",
                    "", MyEffector))
        }
        
        if(class(prettify_effector_name) == "character"){
            MyEffector <- prettify_effector_name
        }
        
        Data <- Data %>%
            mutate(Compound = ifelse(CompoundIsEffector, MyEffector, Compound),
                   Inhibitor = ifelse(Inhibitor != "none", MyEffector, Inhibitor),
                   Group = paste(Compound, Inhibitor, Trial)) %>%
            select(-CompoundIsEffector)
    }
    
    # Error catching for when user specifies linetype, color or shape and
    # doesn't include enough values when effector present
    if(complete.cases(obs_shape[1]) && length(MyEffector) > 0 &&
       complete.cases(MyEffector) &&
       compoundToExtract != "inhibitor 1" &&
       length(complete.cases(obs_shape)) < 2){
        warning("There is an inhibitor or effector present and you have specified what the symbol shapes should be, but you have not listed enough values (you need 2). The default shapes will be used.")
        obs_shape <- NA
    }
    
    if(complete.cases(obs_color[1]) && length(MyEffector) > 0 &&
       complete.cases(MyEffector) &&
       compoundToExtract != "inhibitor 1" &&
       length(complete.cases(obs_color)) < 2){
        warning("There is an inhibitor or effector present and you have specified what the symbol colors should be, but you have not listed enough values (you need 2). The default colors will be used.")
        obs_color <- NA
    }
    
    if(complete.cases(line_color[1]) && length(MyEffector) > 0 &&
       complete.cases(MyEffector) &&
       compoundToExtract != "inhibitor 1" &&
       length(complete.cases(line_color)) < 2){
        warning("There is an inhibitor or effector present and you have specified what the line colors should be, but you have not listed enough values (you need 2). The default colors will be used.")
        line_color <- NA
    }
    
    if(complete.cases(line_type[1]) && length(MyEffector) > 0 &&
       complete.cases(MyEffector) &&
       compoundToExtract != "inhibitor 1" &&
       length(complete.cases(line_type)) < 2){
        warning("There is an inhibitor or effector present and you have specified what the line types should be, but you have not listed enough values (you need 2). The default line types will be used.")
        line_type <- NA
    }
    
    # Always want "none" to be the 1st item on the legend, and we need there
    # to be some value present for "Inhibitor" for function to work correctly.
    Data <- Data %>%
        mutate(Inhibitor = ifelse(is.na(Inhibitor), "none", Inhibitor))
    if(length(MyEffector) > 0){
        Data <- Data %>%
            mutate(Inhibitor = factor(Inhibitor, levels = c("none", MyEffector)))
    }
    
    # Setting up data.frames to graph ---------------------------------------
    # Separating the data by type and calculating trial means
    suppressMessages(
        sim_data_trial <- Data %>%
            filter(Simulated == TRUE &
                       Trial %in% c("mean", "per5", "per95") == FALSE) %>%
            group_by(across(any_of(c("Compound", "Tissue", "Inhibitor",
                                     "Simulated", "Trial", "Group",
                                     "Time", "Time_orig",
                                     "Time_units", "Conc_units")))) %>%
            summarize(Conc = mean(Conc, na.rm = T)) %>%
            ungroup()
    )
    
    sim_data_mean <- Data %>%
        filter(Simulated == TRUE  &
                   Trial %in% c("mean", "per5", "per95")) %>%
        mutate(Group = paste(Compound, Inhibitor, Trial))
    
    # Setting up observed data per user input -------------------------------
    
    obs_data <- Data %>% filter(Simulated == FALSE) %>% droplevels()
    
    if(complete.cases(obs_data_option) &
       str_detect(obs_data_option, "mean")){
        
        suppressMessages(
            obs_data <- obs_data %>%
                group_by(across(any_of(c("Compound", "Tissue", "Inhibitor",
                                         "Simulated", "Trial", "Group",
                                         "Time", "Time_orig",
                                         "Time_units", "Conc_units")))) %>%
                summarize(SDConc = sd(Conc, na.rm = T),
                          Conc = switch(obs_data_option,
                                        "means only" = mean(Conc, na.rm = T),
                                        "mean bars" = mean(Conc, na.rm = T),
                                        "geometric means only" = gm_mean(Conc))) %>%
                ungroup()
        )
    }
    
    # Setting y axis (concentration) ---------------------------------------
    # Setting Y axis limits for both linear and semi-log plots
    if (figure_type == "trial means") {
        Ylim_data <- bind_rows(sim_data_trial, obs_data)
    } else if (figure_type %in% c("trial percentiles", "Freddy", "percentiles")) {
        Ylim_data <- bind_rows(sim_data_trial, sim_data_mean, obs_data)
    } else if (figure_type == "means only") {
        Ylim_data <- sim_data_mean %>% filter(Trial == "mean") }
    if(nrow(Ylim_data) == 0){
        Ylim_data <- bind_rows(sim_data_trial, obs_data, sim_data_mean)
    }
    
    Ylim <- Ylim_data %>% filter(Time_orig >= time_range[1] &
                                     Time_orig <= time_range[2] &
                                     complete.cases(Conc)) %>% pull(Conc) %>%
        range()
    
    if(any(complete.cases(y_axis_limits_lin))){
        Ylim <- y_axis_limits_lin[1:2]
    }
    
    # Some users are sometimes getting Inf for possible upper limit of data,
    # although I haven't been able to reproduce this error. Trying to catch
    # that nonetheless.
    if(is.infinite(Ylim[2]) | is.na(Ylim[2])){
        Ylim[2] <- max(Data$Conc, na.rm = T)
    }
    
    PossYBreaks <- data.frame(Ymax = c(0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50,
                                       100, 200, 500, 1000, 2000, 5000,
                                       10000, 20000, 50000, 100000,
                                       200000, 500000, Inf),
                              YBreaksToUse = c(0.02, 0.05, 0.1, 0.2, 0.5,
                                               1, 2, 5, 10, 20, 50, 100, 200,
                                               500, 1000, 2000, 5000, 10000,
                                               20000, 50000, 100000, 200000))
    
    YBreaksToUse <- PossYBreaks %>% filter(Ymax >= Ylim[2]) %>%
        slice(which.min(Ymax)) %>% pull(YBreaksToUse)
    
    YInterval    <- YBreaksToUse
    YmaxRnd      <- round_up_unit(Ylim[2], YInterval)
    YBreaks      <- seq(0, YmaxRnd, YInterval/2)                    # create labels at major and minor points
    YLabels      <- YBreaks
    YLabels[seq(2,length(YLabels),2)] <- ""                         # add blank labels at every other point i.e. for just minor tick marks at every other point
    
    
    # Figure types ---------------------------------------------------------
    
    # Setting user specifications for shape, linetype, and color where
    # applicable.
    if(is.na(line_type[1])){
        line_type <- c("solid", "dashed")
    }
    
    if(is.na(obs_shape[1])){
        obs_shape <- c(21, 24)
    }
    
    if(complete.cases(line_color[1]) & is.na(obs_color[1])){
        obs_color <- line_color
    }
    
    if(is.na(line_color[1])){
        line_color <- c("black", "black")
    }
    
    if(complete.cases(line_color[1]) && figure_type == "Freddy" &&
       length(line_color) == 1){
        line_color <- rep(line_color, 2)
    }
    
    obs_color <- ifelse((complete.cases(obs_color) & obs_color == "default") |
                            (is.na(obs_color[1]) & figure_type == "Freddy"),
                        "#3030FE", obs_color)
    
    
    ## figure_type: trial means -----------------------------------------------------------
    if(figure_type == "trial means"){
        
        NumTrials <- length(unique(sim_data_trial$Trial))
        AlphaToUse <- ifelse(complete.cases(line_transparency),
                             line_transparency,
                             ifelse(NumTrials > 10, 0.05, 0.4))
        
        if(length(MyEffector) > 0 && complete.cases(MyEffector[1]) &&
           MyEffector[1] != "none" & compoundToExtract != "inhibitor 1"){
            
            ## linear plot
            A <- ggplot(sim_data_trial,
                        aes(x = Time, y = Conc, group = Group,
                            linetype = Inhibitor, shape = Inhibitor,
                            color = Inhibitor)) +
                geom_line(alpha = AlphaToUse, 
                          lwd = ifelse(is.na(line_width), 1, line_width), 
                          show.legend = FALSE) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial == "mean"), 
                          lwd = ifelse(is.na(line_width), 1, line_width)) +
                scale_shape_manual(values = obs_shape[1:2]) +
                scale_linetype_manual(values = line_type[1:2]) +
                scale_color_manual(values = line_color[1:2])
            
            if(nrow(obs_data) > 0){
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <-  A + geom_point(data = obs_data, size = 2,
                                         stroke = 1)
                } else {
                    # Glitch when the user has supplied observed data
                    # with a different number of inhibitors than
                    # sim_data_trial, e.g., when the obs data came
                    # with the simulator output file. Addressing that.
                    if(length(unique(obs_data$Inhibitor)) == 1){
                        obs_color <- obs_color[1]
                    }
                    
                    A <- A +
                        geom_point(data = obs_data, size = 2,
                                   fill = obs_color, alpha = 0.5,
                                   stroke = 1) +
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, stroke = 1)
                }
            }
            
        } else {
            
            ## linear plot
            A <- ggplot(sim_data_trial,
                        aes(x = Time, y = Conc, group = Trial)) +
                geom_line(alpha = AlphaToUse,
                          lwd = ifelse(is.na(line_width), 1, line_width),
                          linetype = line_type[1],
                          color = line_color[1]) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial == "mean"),
                          lwd = ifelse(is.na(line_width), 1, line_width),
                          linetype = line_type[1],
                          color = line_color[1])
            
            if(nrow(obs_data) > 0){
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + geom_point(data = obs_data, size = 2,
                                        shape = obs_shape[1], stroke = 1)
                } else {
                    
                    A <- A + geom_point(data = obs_data, size = 2,
                                        fill = obs_color[1], alpha = 0.5,
                                        shape = obs_shape[1], stroke = 1) +
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, shape = obs_shape[1], stroke = 1)
                }
            }
        }
    }
    
    ## figure_type: percentiles ----------------------------------------------------------
    if(str_detect(figure_type, "percentile")){
        # graphs with 95th percentiles
        
        AlphaToUse <- ifelse(complete.cases(line_transparency),
                             line_transparency, 0.25)
        
        if(length(MyEffector) > 0 && complete.cases(MyEffector[1]) &&
           MyEffector[1] != "none" & compoundToExtract != "inhibitor 1"){
            
            A <- ggplot(sim_data_mean %>%
                            filter(Trial %in% c("per5", "per95")) %>%
                            mutate(Group = paste(Group, Trial)),
                        aes(x = Time, y = Conc,
                            linetype = Inhibitor, shape = Inhibitor,
                            color = Inhibitor,
                            group = Group)) +
                geom_line(alpha = AlphaToUse, lwd = ifelse(is.na(line_width), 0.8, line_width)) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial == "mean"),
                          lwd = ifelse(is.na(line_width), 1, line_width))  +
                scale_shape_manual(values = obs_shape[1:2]) +
                scale_linetype_manual(values = line_type[1:2]) +
                scale_color_manual(values = line_color[1:2])
            
            if(nrow(obs_data) > 0){
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + geom_point(data = obs_data, size = 2,
                                        stroke = 1)
                } else {
                    A <- A +
                        geom_point(data = obs_data, size = 2,
                                   fill = obs_color, alpha = 0.5,
                                   stroke = 1) +
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, stroke = 1)
                }
            }
            
        } else {
            
            ## linear plot
            A <- ggplot(sim_data_mean %>% filter(Trial != "mean"),
                        aes(x = Time, y = Conc, group = Trial)) +
                geom_line(alpha = AlphaToUse, 
                          lwd = ifelse(is.na(line_width), 0.8, line_width),
                          linetype = line_type[1],
                          color = line_color[1]) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial == "mean"),
                          lwd = ifelse(is.na(line_width), 1, line_width),
                          linetype = line_type[1],
                          color = line_color[1])
            
            if(nrow(obs_data) > 0){
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + geom_point(data = obs_data, size = 2,
                                        stroke = 1, shape = obs_shape[1])
                } else {
                    A <- A +
                        geom_point(data = obs_data, size = 2,
                                   fill = obs_color[1], alpha = 0.5,
                                   stroke = 1, shape = obs_shape[1]) +
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, shape = obs_shape[1], stroke = 1)
                }
            }
        }
    }
    
    ## figure_type: Freddy --------------------------------------------------------------
    if(figure_type == "Freddy"){
        
        NumTrials <- length(unique(sim_data_trial$Trial))
        AlphaToUse <- ifelse(complete.cases(line_transparency),
                             line_transparency,
                             ifelse(NumTrials > 10, 0.05, 0.25))
        
        if(length(MyEffector) > 0 && complete.cases(MyEffector[1]) &&
           MyEffector[1] != "none" & compoundToExtract != "inhibitor 1"){
            
            ## linear plot
            A <- ggplot(data = sim_data_mean %>%
                            filter(Trial == "mean"),
                        aes(x = Time, y = Conc, group = Group,
                            linetype = Inhibitor, shape = Inhibitor,
                            color = Inhibitor)) +
                geom_line(lwd = ifelse(is.na(line_width), 1, line_width)) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial %in% c("per5", "per95")),
                          alpha = AlphaToUse, 
                          lwd = ifelse(is.na(line_width), 1, line_width)) +
                scale_shape_manual(values = obs_shape[1:2]) +
                scale_linetype_manual(values = line_type[1:2]) +
                scale_color_manual(values = line_color[1:2])
            
            if(nrow(obs_data) > 0){
                # When figure_type == "Freddy", I want the default to be
                # a blue-purple semi-transparent fill. However, I want
                # people to have the option to override that, so
                # setting obs_color to "none" will override the
                # "Freddy" default. -LS
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + geom_point(data = obs_data, size = 2,
                                        fill = NA, stroke = 1)
                } else {
                    # This is the situation when the user has
                    # requested a specific color for the Freddy figure
                    # type.
                    A <- A +
                        geom_point(data = obs_data, size = 2,
                                   fill = obs_color, alpha = 0.5,
                                   stroke = 1) +
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, stroke = 1)
                }
            }
            
        } else {
            
            ## linear plot
            A <- ggplot(sim_data_trial,
                        aes(x = Time, y = Conc, group = Trial)) +
                geom_line(alpha = AlphaToUse, 
                          lwd = ifelse(is.na(line_width), 1, line_width),
                          linetype = line_type[1],
                          color = line_color[1]) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial == "mean"),
                          lwd = ifelse(is.na(line_width), 1, line_width), linetype = line_type[1],
                          color = line_color[1]) +
                geom_line(data = sim_data_mean %>%
                              filter(Trial %in% c("per5", "per95")),
                          linetype = line_type[2],
                          color = line_color[2])
            
            if(nrow(obs_data) > 0){
                # When figure_type == "Freddy", I want the default to be
                # a blue-purple semi-transparent fill. However, I want
                # people to have the option to override that, so
                # setting obs_color to "none" will override the
                # "Freddy" default. -LS
                if(all(is.na(obs_color)) | obs_color[1] == "none"){
                    A <- A + geom_point(data = obs_data, size = 2,
                                        fill = NA, stroke = 1,
                                        shape = obs_shape[1])
                } else {
                    # This is the situation when the user has
                    # requested a specific color for the Freddy figure
                    # type.
                    A <- A +
                        geom_point(data = obs_data, size = 2,
                                   fill = obs_color[1], alpha = 0.5,
                                   stroke = 1, shape = obs_shape[1]) +
                        geom_point(data = obs_data, size = 2,
                                   fill = NA, stroke = 1,
                                   shape = obs_shape[1])
                }
            }
        }
    }
    
    ## figure_type: means only -----------------------------------------------------------
    if(figure_type == "means only"){
        
        if(length(MyEffector) > 0 && complete.cases(MyEffector[1]) &&
           MyEffector[1] != "none" & compoundToExtract != "inhibitor 1"){
            
            A <- ggplot(sim_data_mean %>%
                            filter(Trial == "mean") %>%
                            mutate(Group = paste(Group, Trial)),
                        aes(x = Time, y = Conc, linetype = Inhibitor,
                            color = Inhibitor)) +
                geom_line(lwd = ifelse(is.na(line_width), 1, line_width)) +
                scale_linetype_manual(values = line_type[1:2]) +
                scale_color_manual(values = line_color[1:2])
            
        } else {
            
            A <- ggplot(sim_data_mean %>%
                            filter(Trial == "mean"),
                        aes(x = Time, y = Conc)) +
                geom_line(lwd = ifelse(is.na(line_width), 1, line_width),
                          linetype = line_type[1],
                          color = line_color[1])
        }
    }
    
    
    # Applying aesthetics ------------------------------------------------
    if(nrow(obs_data) == 0){
        A <- A + guides(shape = "none")
    }
    
    if(complete.cases(obs_data_option) & obs_data_option == "mean bars" &
       figure_type != "means only"){
        A <- A +
            geom_errorbar(data = obs_data,
                          aes(x = Time, ymin = Conc - SDConc,
                              ymax = Conc + SDConc),
                          width = (time_range[2] - time_range[1])/80)
    }
    
    if(t0 != "simulation start"){
        time_range_relative <- time_range - t0_num
    } else {
        time_range_relative <- time_range
    }
    
    # If the user requested specific doses, don't pad the x axis b/c it's just
    # not what they requested. However, add a little extra space at the right
    # edge b/c otherwise axis tick labels are getting clipped.
    if(complete.cases(time_range_input) &&
       str_detect(tolower(time_range_input), "dose") &
       pad_x_axis == FALSE){
        A <- A + scale_x_continuous(breaks = XBreaks, labels = XLabels,
                                    expand = c(0,0)) +
            theme(plot.margin = unit(c(0.5, 0.75, 0.5, 0.5), "cm"))
    } else {
        A <- A +
            scale_x_continuous(breaks = XBreaks, labels = XLabels,
                               expand = expansion(
                                   mult = c(ifelse(pad_x_axis, 0.02, 0), 0.04)))
    }
    
    A <- A +
        scale_y_continuous(limits = c(0, YmaxRnd), breaks = YBreaks,
                           labels = YLabels,
                           expand = expansion(mult = c(0, 0.1))) +
        labs(x = xlab, y = ylab,
             linetype = ifelse(complete.cases(legend_label),
                               legend_label, "Inhibitor"),
             shape = ifelse(complete.cases(legend_label),
                            legend_label, "Inhibitor"),
             color = ifelse(complete.cases(legend_label), 
                            legend_label, "Inhibitor")) +
        coord_cartesian(xlim = time_range_relative) +
        theme(panel.background = element_rect(fill="white", color=NA),
              legend.key = element_rect(fill = "white"),
              axis.ticks = element_line(color = "black"),
              axis.text = element_text(color = "black"),
              axis.title = element_text(color = "black", face = "bold"),
              axis.line.x.bottom = element_line(color = "black"),
              axis.line.y.left = element_line(color = "black"),
              text = element_text(family = "Calibri"))
    
    # If the user didn't want the legend or if the graph is of Inhibitor1,
    # remove legend.
    if(include_legend == FALSE | compoundToExtract == "inhibitor 1"){
        A <- A + theme(legend.position = "none")
    }
    
    near_match <- function(x, t) {x[which.min(abs(t - x))]} # LS to HB: Clever solution to this problem! :-)
    
    if(is.na(y_axis_limits_log[1])){ # Option to consider for the future: Allow user to specify only the upper limit, which would leave y_axis_limits_log[1] as NA?
        
        Ylim_log <- Ylim
        
        Ylim_log[1] <- Ylim_data %>%
            filter(Time == near_match(Ylim_data$Time, time_range_relative[2])) %>%
            pull(Conc) %>% min()
        
        # If Ylim_log[1] is 0, which can happen when the concs are really low, that
        # is undefined for log transformations. Setting it to be max value / 100
        # when that happens.
        Ylim_log[1] <- ifelse(Ylim_log[1] == 0, 
                              Ylim_log[2]/100, Ylim_log[1])
        Ylim_log[1] <- round_down(Ylim_log[1])
        Ylim_log[2] <- round_up(Ylim[2])
        
    } else {
        # If user set Ylim_log[1] to 0, set it to 1/100th the higher value and
        # tell them we can't use 0.
        if(y_axis_limits_log[1] <= 0){
            y_axis_limits_log[1] <- y_axis_limits_log[2]/100
            warning("You requested a lower y axis limit that is undefined for log-transformed data. The lower y axis limit will be set to 1/100th the upper y axis limit instead.")
        }
        
        Ylim_log <- y_axis_limits_log
        
        # Previously, we *had* been rounding here, but I think the user may
        # actually want a specific set of limits, so commenting that out for
        # now. -LS 
        # Ylim_log[1] <- round_down(Ylim_log[1]) 
        # Ylim_log[2] <- round_up(Ylim[2])
        
    }
    
    YLogBreaks <- as.vector(outer(1:9, 10^(log10(Ylim_log[1]):log10(Ylim_log[2]))))
    YLogBreaks <- YLogBreaks[YLogBreaks >= Ylim_log[1] & YLogBreaks <= Ylim_log[2]]
    YLogLabels   <- rep("",length(YLogBreaks))
    
    
    if(is.na(y_axis_limits_log[1]) |
       # checking whether Ylim_log values are a factor of 10 b/c, if they are,
       # then just use the Ylim_log that we would have come up with using the
       # other method b/c that makes prettier breaks
       all(log10(Ylim_log) == round(log10(Ylim_log)))){
        
        # add labels at order of magnitude
        YLogLabels[seq(1,length(YLogLabels),9)] <- YLogBreaks[seq(1,length(YLogLabels),9)]
        
    } else {
        
        # add labels for the 1st and last YLogBreaks and also 3 in between. The
        # odd fractions are b/c I want to have them spaced out somewhat
        # regularly, and that requires nonlinear intervals since it's log
        # transformed.
        YLogLabels[1] <- YLogBreaks[1]
        Nbreaks <- length(YLogBreaks)
        YLogLabels[Nbreaks] <- YLogBreaks[Nbreaks]
        YLogLabels[round(Nbreaks/4)] <- YLogBreaks[round(Nbreaks/4)]
        YLogLabels[round(2*Nbreaks/3)] <- YLogBreaks[round(2*Nbreaks/3)]
        YLogLabels[round(5*Nbreaks/6)] <- YLogBreaks[round(5*Nbreaks/6)]
        
    } 
    
    B <- suppressMessages(
        A + scale_y_log10(limits = Ylim_log, breaks = YLogBreaks,
                          labels = YLogLabels) +
            # labels = function(.) format(., scientific = FALSE, drop0trailing = TRUE)) +
            coord_cartesian(xlim = time_range_relative)
    )
    
    # both plots together, aligned vertically
    if(compoundToExtract == "inhibitor 1"){
        AB <- suppressWarnings(
            ggpubr::ggarrange(A, B, ncol = 1, labels = c("A", "B"),
                              align = "v")
        )
        
    } else {
        # If the user didn't want the legend or if the graph is of Inhibitor1,
        # remove legend.
        if(include_legend == FALSE | compoundToExtract == "inhibitor 1"){
            AB <- suppressWarnings(
                ggpubr::ggarrange(A, B, ncol = 1, labels = c("A", "B"),
                                  legend = "none", align = "v"))
        } else {
            AB <- suppressWarnings(
                ggpubr::ggarrange(A, B, ncol = 1, labels = c("A", "B"),
                                  common.legend = TRUE, legend = "right",
                                  align = "v"))
        }
    }
    
    Out <- list("Graphs" = AB)
    
    if(return_data){
        Out[["Data"]] <- Data
    }
    
    if(return_indiv_graphs){
        Out[["Linear graph"]] <- A
        Out[["Semi-log graph"]] <- B
    }
    
    if(length(Out) == 1){
        Out <- Out[[1]]
    }
    
    return(Out)
}




