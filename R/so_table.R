#' Make simulated vs. observed tables for reports
#'
#' \code{so_table} creates simulated vs. observed tables for reports and
#' presentations, including reporting means, CVs, confidence intervals or
#' percentiles, and ratios of simulated vs. observed mean values. The data it
#' uses for these calculations are standard information about the observed and
#' simulated data in the format generated by running \code{getSectionInfo}.
#'
#' @param Info information about the simulated and observed data. This is output
#'   from the function \code{getSectionInfo} or the name of the Excel file to be
#'   piped to \code{getSectionInfo}.
#' @param sheet the sheet name to read if "Info" is not the output from
#'   \code{getSectionInfo} but the name of an Excel file
#' @param ArithOrGeom Arithmetic or geometric means? Only specify this if you'd
#'   like to override the value listed in "Info". If no value is specified here
#'   or in "Info", the default is "geometric".
#' @param variability_option  What type of variability would you like the table
#'   to include? Options are: "90% CI", "95% CI", "95th percentiles", or any
#'   combination of those, e.g. \code{variability_option = c("90% CI", "95th
#'   percentiles")}
#' @param concatVariability Would you like to have the variability concatenated?
#'   TRUE or FALSE. If "TRUE", the output will be formatted into a single row
#'   and listed as the lower confidence interval or percentile to the upper. Ex:
#'   "2400 to  2700"
#' @param includeT12 TRUE or FALSE on whether to include t1/2 as a parameter in
#'   the output table
#' @return a data.frame
#' @export
#' @examples
#' # No examples yet.


so_table <- function(Info, sheet = NA,
                     ArithOrGeom = NA,
                     variability_option = "90% CI",
                     concatVariability = TRUE,
                     includeT12 = FALSE){

      if(class(Info) != "list"){
            Info <- readInfo <- getSectionInfo(Info, sheet = sheet)
      }

      D1 <- c("AUCinf", "CL", "Cmax", "HalfLife", "tmax")
      D2 <- sub("AUCinf", "AUCtau", D1)

      D1 <- paste0(D1, "_dose1")
      D2 <- paste0(D2, "_ss")

      ObsToPull <- c(
            c(D1, paste0(D1, "_withEffector"),
              D2, paste0(D2, "_withEffector")),

            paste0(c(D1, paste0(D1, "_withEffector"),
                     D2, paste0(D2, "_withEffector")), "_CV")
      )

      PKToPull <- ObsToPull[!str_detect(ObsToPull, "_CV")]

      # Info for the section
      SectionInput <- Info[
            1:(which(Info$Item == "Details for the clinical study") - 1), ]

      # Info we'll use here
      ObsInput <- Info[
            (which(Info$Item == "Details for the clinical study") + 2):nrow(Info), ] %>%
            mutate(Value = as.numeric(Value))

      # Getting PK parameters from the AUC tab
      MyPKParam <- switch(
            paste(SectionInput$Value[which(SectionInput$RName == "DoseRegimen")],
                  SectionInput$Value[which(SectionInput$RName == "EffectorPresent")]),
            "SD no" = PKToPull[
                  str_detect(PKToPull, "dose1") &
                        !str_detect(PKToPull, "withEffector")],
            "SD yes" = PKToPull[
                  str_detect(PKToPull, "dose1")],
            "MD no" = PKToPull[!str_detect(PKToPull, "withEffector")],
            "MD yes" = PKToPull)

      Extract <- extractPK(SectionInput$Value[which(SectionInput$RName == "SimFile")],
                           PKparameters = MyPKParam)

      MyPKResults <- do.call(bind_rows, Extract)

      # Calculating GMR where appropriate
      if(str_detect(tolower(Info$Value[which(Info$RName == "EffectorPresent")]),
                    "y")){
            if(any(str_detect(MyPKParam, "dose1")) &
               all(c("AUCinf_dose1_withEffector", "AUCinf_dose1",
                     "Cmax_dose1_withEffector", "Cmax_dose1") %in%
                   names(MyPKResults))){
                  MyPKResults <- MyPKResults %>%
                        mutate(GMR_AUCinf_dose1 = AUCinf_dose1_withEffector /
                                     AUCinf_dose1,
                               GMR_Cmax_dose1 = Cmax_dose1_withEffector / Cmax_dose1)
            }

            if(any(str_detect(MyPKParam, "ss")) &
               all(c("AUCtau_ss_withEffector", "AUCtau_ss",
                     "Cmax_ss_withEffector", "Cmax_ss") %in%
                   names(MyPKResults))){
                  MyPKResults <- MyPKResults %>%
                        mutate(GMR_AUCtau_ss = AUCtau_ss_withEffector /
                                     AUCtau_ss,
                               GMR_Cmax_ss = Cmax_ss_withEffector / Cmax_ss)
            }
      }

      MeanType <- ifelse(is.na(ArithOrGeom),
                         SectionInput$Value[which(SectionInput$RName == "ArithOrGeom")],
                         ArithOrGeom)
      MeanType <- ifelse(is.na(MeanType), "geometric", MeanType)

      if(MeanType == "geometric"){
            MyPKResults <- MyPKResults %>%
                  summarize(across(.cols = everything(),
                                   .fns = list(GMean = gm_mean,
                                               CV = gm_CV,
                                               CI_10 = function(.) gm_conf(., CI = 0.9)[[1]],
                                               CI_90 = function(.) gm_conf(., CI = 0.9)[[2]],
                                               CI_05 = function(.) gm_conf(., CI = 0.95)[[1]],
                                               CI_95 = function(.) gm_conf(., CI = 0.95)[[2]],
                                               Q5th = function(.) quantile(., 0.05),
                                               Q95th = function(.) quantile(., 0.95),
                                               Med = median,
                                               Min = min,
                                               Max = max),
                                   .names = "{.col} {.fn}"))
      } else {

            MyPKResults <- MyPKResults %>%
                  summarize(across(.cols = everything(),
                                   .fns = list(GMean = mean,
                                               CV = function(.) sd(.)/mean(.),
                                               CI_10 = function(.) confInt(., 0.9)[[1]],
                                               CI_90 = function(.) confInt(., 0.9)[[2]],
                                               CI_05 = function(.) confInt(., 0.95)[[1]],
                                               CI_95 = function(.) confInt(., 0.95)[[2]],
                                               Q5th = function(.) quantile(., 0.05),
                                               Q95th = function(.) quantile(., 0.95),
                                               Med = median,
                                               Min = min,
                                               Max = max),
                                   .names = "{.col} {.fn}"))
      }

      VarOpt1 <- variability_option[1]
      VaribilityNames <- switch(VarOpt1,
                                "90% CI" = c("CI_10", "CI_90"),
                                "95% CI" = c("CI_05", "CI_95"),
                                "95th percentiles" = c("Q5th", "Q95th"))

      MyPKResults <- MyPKResults %>%
            pivot_longer(cols = everything(), names_to = "Param",
                         values_to = "Value") %>%
            mutate(Value = if_else(str_detect(Param, "CV"),
                                   round(Value * 100, 0),
                                   signif(Value, 3))) %>%  # not sure of the best option for rounding here
            separate(col = Param, into = c("PKParam", "Stat"), sep = " ") %>%
            filter((str_detect(PKParam, "tmax") & Stat %in% c("Med", "Min", "Max")) |
                         (!str_detect(PKParam, "tmax")
                          & Stat %in% c("Med", "Min", "Max") == FALSE)) %>%
            mutate(Stat = recode(Stat, "Med" = "GMean",
                                 "Min" = VaribilityNames[1],
                                 "Max" = VaribilityNames[2])) %>%
            pivot_wider(names_from = PKParam, values_from = Value)

      # Observed data. Not included when section is model application.
      if(SectionInput$Value[which(SectionInput$RName == "ModelPurpose")] !=
         "application"){

            MyObsPK <- ObsInput %>%
                  filter(RName %in% c(MyPKParam, paste0(MyPKParam, "_CV"))) %>%
                  select(RName, Value) %>%
                  mutate(Value = ifelse(str_detect(RName, "CV"),
                                        round(Value * 100, 0), signif(Value, 3)),
                         Stat = ifelse(str_detect(RName, "CV"), "CV_obs", "GMean"),
                         RName = sub("_CV", "", RName)) %>%
                  pivot_wider(names_from = RName, values_from = Value)

            # Only want to keep the columns where there are values for the observed
            # mean data.
            MyObsPK <- MyObsPK %>% select(where(function(x) complete.cases(x[1])))

            # Calculating S/O
            GMeans <- MyPKResults %>% filter(Stat == "GMean") %>%
                  pivot_longer(names_to = "PKParam_short", values_to = "Sim",
                               cols = -Stat) %>%
                  left_join(MyObsPK %>% filter(Stat == "GMean") %>%
                                  pivot_longer(names_to = "PKParam_short", values_to = "Obs",
                                               cols = -Stat)) %>%
                  mutate(S_O = round(Sim / Obs, 1)) %>%
                  select(PKParam_short, S_O) %>%
                  pivot_wider(names_from = PKParam_short, values_from = S_O) %>%
                  mutate(Stat = "S/O")

            # Calculating GMR where appropriate
            if(str_detect(tolower(Info$Value[which(Info$RName == "EffectorPresent")]),
                          "y")){

                  if(any(str_detect(MyPKParam, "dose1") &
                         any(str_detect(names(MyObsPK), "dose1")))){
                        MyObsPK <- MyObsPK %>%
                              mutate(GMR_AUCinf_dose1 =
                                           signif(AUCinf_dose1_withEffector /
                                                        AUCinf_dose1, 3),
                                     GMR_Cmax_dose1 =
                                           signif(Cmax_dose1_withEffector /
                                                        Cmax_dose1, 3))
                  }

                  if(any(str_detect(MyPKParam, "ss")) &
                     any(str_detect(names(MyObsPK), "ss"))){
                        MyObsPK <- MyObsPK %>%
                              mutate(GMR_AUCtau_ss =
                                           signif(AUCtau_ss_withEffector /
                                                        AUCtau_ss, 3),
                                     GMR_Cmax_ss =
                                           signif(Cmax_ss_withEffector / Cmax_ss, 3))
                  }
            }

            # Next, selecting only the appropriate columns for table, making
            # everything character, and adding % symbols to CV rows
            MyPKResults <- MyPKResults %>%
                  bind_rows(MyObsPK %>% mutate(Stat = ifelse(Stat == "GMean",
                                                             "GMean_obs", Stat))) %>%
                  bind_rows(GMeans)

            MyPKResults <- MyPKResults[, names(MyObsPK)]

      }

      MyPKResults <- MyPKResults %>%
            mutate_all(.funs = as.character) %>%
            mutate(across(.cols = !Stat,
                          .fns = function(x) ifelse(str_detect(Stat, "CV"),
                                                    paste0(x, "%"), x)),
                   across(.cols = everything(),
                          .fns = function(x) ifelse(x == "NA%", NA, x)))
      # If this throws an error for you, try running "tidyverse_update()", copy
      # whatever it says is out of date, restart your R session (Ctrl Shift
      # F10), and then paste the output (something like
      # "install.packages(c("dbplyr", "dplyr", "dtplyr", ... ") and execute.

      if(str_detect(tolower(Info$Value[which(Info$RName == "EffectorPresent")]),
                    "y")){
            # Only want AUC, Cmax w/ and w/out effector
            MyPKResults <- MyPKResults %>%
                  select(Stat, matches("AUC|Cmax"))

            PKToPull <-  c(PKToPull, "GMR_AUCinf_dose1",
                           "GMR_Cmax_dose1", "GMR_AUCtau_ss", "GMR_Cmax_ss")

      }

      # Talked w/Christiane about including t1/2 since that's included in the table,
      # and she said that Massoud prefers to NOT include it b/c there can be glitches
      # with its calculation. It's only included if there's a specific reason the
      # client wants it. Optionally including it.
      if(includeT12 == FALSE){
            MyPKResults <- MyPKResults %>% select(-matches("HalfLife"))
      }

      # Filtering rows as requested by user
      VarOpts_tableRows <- list("90% CI" = c("CI_10", "CI_90"),
                                "95% CI" = c("CI_05", "CI_95"),
                                "95th percentiles" = c("Q5th", "Q95th"))
      VarOptsNotChosen <- setdiff(c("90% CI", "95% CI", "95th percentiles"),
                                  variability_option)

      if(length(VarOptsNotChosen) > 0){
            MyPKResults <- MyPKResults %>%
                  filter(!Stat %in% unlist(VarOpts_tableRows[VarOptsNotChosen]))
      }

      # Concatenating the rows w/lower and upper limits of variability when
      # requested
      if(concatVariability){

            VarRows <- VarOpts_tableRows[variability_option]
            for(j in names(VarRows)){
                  temp <- MyPKResults %>%
                        filter(Stat %in% as.character(unlist(VarRows[[j]]))) %>%
                        mutate(across(.cols = !matches("Stat"),
                                      .fns = function(x) paste(x[1], "to", x[2])),
                               Stat = switch(j,
                                             "90% CI" = "CI90concat",
                                             "95% CI" = "CI95concat",
                                             "95th percentile" = "Q95thconcat"))

                  MyPKResults[which(MyPKResults$Stat == VarRows[[j]][1]), ] <-
                        temp[1, ]
                  MyPKResults <- MyPKResults %>% filter(Stat != VarRows[[j]][2])
                  rm(temp)
            }
      }

      # Renaming statistics to match what's in template
      StatNames <- c("GMean" = "Simulated",
                     "CV" = "CV%",
                     "CI_10" = "90% CI - Lower",
                     "CI_90" = "90% CI - Upper",
                     "CI90concat" = "90% CI",
                     "CI_05" = "95% CI - Lower",
                     "CI_10" = "95% CI - Upper",
                     "CI95concat" = "95% CI",
                     "Q5th" = "5th Percentile",
                     "Q95th" = "95th Percentile",
                     "Q95thconcat" = "5th to 95th Percentile",
                     "GMean_obs" = "Observed",
                     "CV_obs" = "CV%",
                     "S/O" = "S/O")

      MyPKResults <- MyPKResults %>%
            mutate(Statistic = as.character(Stat),
                   Statistic = StatNames[Statistic]) %>%
            select(-Stat) %>%
            select(Statistic, everything())

      # Getting columns in a good order
      MyPKResults <- MyPKResults %>%
            select(any_of(c("Statistic", PKToPull)))

      # Adding final column names
      PKToPull_pretty <-
            sapply(PKToPull,
                   FUN = function(x) ifelse(str_detect(x, "_dose1"),
                                            paste("Dose 1", sub("_dose1", "", x)),
                                            paste("Steady-state", sub("_ss", "", x))))
      PKToPull_pretty <- sub("_withEffector", " with effector", PKToPull_pretty)
      PKToPull_pretty <- sub("CL", "CL/F (L/h)", PKToPull_pretty)
      PKToPull_pretty <- sub("AUCinf", "AUC0 to inf (h*ng/mL)", PKToPull_pretty)
      PKToPull_pretty <- sub("AUCtau", "AUC0 to tau (h*ng/mL)", PKToPull_pretty)
      PKToPull_pretty <- sub("Cmax", "Cmax (ng/mL)", PKToPull_pretty)
      PKToPull_pretty <- sub("HalfLife", "t1/2 (h)", PKToPull_pretty)
      PKToPull_pretty <- sub("tmax", "tmax (h)", PKToPull_pretty)
      PKToPull_pretty[str_detect(PKToPull_pretty, "with effector")] <-
            sub(" \\(", " with effector (", PKToPull_pretty[str_detect(PKToPull_pretty, "with effector")])
      PKToPull_pretty[str_detect(PKToPull_pretty, "with effector")] <-
            sub(" with effector$", "", PKToPull_pretty[str_detect(PKToPull_pretty, "with effector")])
      PKToPull_pretty <- sub("GMR_", "geometric mean ratio ", PKToPull_pretty)

      PKToPull_pretty <- c("Statistic" = "Statistic", PKToPull_pretty)

      names(MyPKResults) <- PKToPull_pretty[names(MyPKResults)]

      return(MyPKResults)
}
