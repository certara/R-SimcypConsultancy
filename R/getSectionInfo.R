#' Get information from an Excel report-input file about a section for a report
#'
#' \code{getSectionInfo} pulls information from an Excel file generated by
#' \code{\link{generateReportInputForm}} to feed into the function
#' \code{\link{so_table}}. Since this requires comparing observed data to a
#' simulator output file, setting up the input for this function requires a few
#' steps: \enumerate{ \item{Use the function
#' \code{\link{generateReportInputForm}} to create an Excel file where you can
#' enter information about your project.} \item{Go to the tab "observed data"
#' and enter details about your observed data. It's ok if you don't have all the
#' information; anything that's missing won't be included in the final S/O
#' table. It's also ok to rename this tab and/or make copies of it within the
#' same Excel file for making other S/O tables.} \item{Go to the tab "section
#' input" and fill out information here for the specific section you're making
#' this S/O table for. Make sure that whatever you list for the tab that
#' contains information about the observed data is exactly the same as the
#' actual tab name that you filled out in step 2. Also make sure that the file
#' names include the full file path.} \item{Save your Excel file.} \item{Here,
#' within RStudio (or within the shiny app that we plan to make!), run this
#' function using the name of that Excel file as input for
#' \code{report_input_file} and the name of the "section input" tab as the input
#' for \code{sheet}. Note: If the Excel file lives on SharePoint, you'll need to
#' close it or this function will just keep running and not generate any output
#' while it waits for access to the file.} }
#'
#' @param report_input_file the name of the Excel file formatted exactly like
#'   "Report input template.xlsx", including the path if it's in any other
#'   directory than the current one
#' @param sheet the sheet in the Excel file that contains information about this
#'   section of the report
#' @param section_input_DF a data.frame object that contains information about
#'   this section of the report and is the filled-out version of
#'   ReportInputForm[["Section input form"]]. If this is NOT set to NA, then
#'   this will be used for section details instead of reading the Excel sheet
#'   listed. You still must fill out \code{report_input_file}, though, because
#'   that will be used to read in data about the clinical study.
#'
#' @return a list object
#' @export
#'
#' @examples
#' # No examples yet.
#'
getSectionInfo <- function(report_input_file = NA,
                           sheet = NA,
                           section_input_DF = NA){

      if("data.frame" %in% class(section_input_DF)){
            InputXL <- section_input_DF
      } else {
            InputXL <- suppressMessages(
                  readxl::read_excel(path = report_input_file,
                                     sheet = sheet))
      }

      # Making each of the items in InputXL its own named item in a list so that
      # output from getSectionInfo will be exclusively a list rather than a list
      # that contains a data.frame, since the latter is annoying to code
      # namewise.
      InfoList <- InputXL %>% select(-Item) %>%
            mutate(Value = gsub("\\\\", "/", Value),
                   Value = sub("(https://)?s08sharepoint.certara.com/sites/consult/",
                               SimcypDir$SharePtDir, Value)) %>%
            pivot_wider(names_from = RName, values_from = Value) %>%
      as.list()

      if(is.na(InfoList$ClinStudyTab) & InfoList$ModelPurpose != "application"){
            warning("The modeling phase is not listed as 'application', but no clinical study tab is listed for comparing to simulated data. Are you sure that's correct? The information extracted for this section will not be compared to any observed data.")
      }

      ClinXL <- suppressMessages(readxl::read_excel(path = report_input_file,
                                                    sheet = ClinStudyTab))

      InfoList <- c(InfoList,
                ClinXL %>% select(-Item) %>%
                      filter(complete.cases(RName)) %>%
                      pivot_wider(names_from = RName, values_from = Value) %>%
                      as.list())

      Deets <- extractExpDetails(sim_data_file = SimFile)

      # Tidying up the names used for populations so that they look nice in report
      Pop <- tidyPop(Deets$Pop)
      NumSimSubj <- Deets[["NumSubjTrial"]] * Deets[["NumTrials"]]
      DoseFreq <- switch(as.character(Deets[["DoseInt_sub"]]),
                         "12" = "BID",
                         "24" = "QD",
                         "8" = "TID",
                         "Single Dose" = "single dose")
      Deets[["Inhibitor"]] <- tolower(gsub(
            "SV-|Sim-|_EC|_SR|-MD|-SD|-[1-9]00 mg [QMSTBI]{1,2}D|_Fasted Soln|_Fed Capsule",
            "",
            Deets[["Inhibitor"]]))
      DoseFreq_inhib <- switch(as.character(Deets[["DoseInt_inhib"]]),
                               "12" = "BID",
                               "24" = "QD",
                               "8" = "TID",
                               "Single Dose" = "single dose")

      # Day substrate was administered
      StartDoseDay_sub <-
            as.numeric(sub("Day ", "",
                           str_split(Deets[["StartDayTime_sub"]], ", ")[[1]][1]))

      # Days inhibitor was administered
      StartDoseDay_inhib <- as.numeric(sub("Day ", "",
                                           str_split(Deets[["StartDayTime_inhib"]], ", ")[[1]][1]))

      LastDoseDay_inhib <-
            (Deets[["DoseInt_inhib"]] * Deets[["NumDoses_inhib"]])/24


      # Putting everything together
      InfoList <- c(InfoList, Deets,
                    "Pop" = Pop,
                    "NumSimSubj" = NumSimSubj,
                    "DoseFreq" = DoseFreq,
                    "DoseFreq_inhib" = DoseFreq_inhib,
                    "StartDoseDay_sub" = StartDoseDay_sub,
                    "StartDoseDay_inhib" = StartDoseDay_inhib,
                    "LastDoseDay_inhib" = LastDoseDay_inhib)

      InfoList <- InfoList[sort(names(InfoList))]

      return(InfoList)
}
