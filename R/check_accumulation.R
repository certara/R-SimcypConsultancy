#' Create a graph of simulated concentrations to check for accumulation
#'
#' Create a graph with time on the x axis and then some useful concentration
#' point -- C0, Cmax, Cmin (see notes on usage), or Clast for each dose -- on
#' the y axis. Optionally overlay this graph with the concentration-time data
#' for that same compound or a different one. For example, you could create a
#' graph with points for Clast for an inhibitor and then lines showing the
#' substrate concentration-time data overlaid on top of that. This way, you can
#' check whether the substrate is dosed after the inhibitor reaches steady
#' state, and you could also check whether the inhibitor was present the entire
#' time the substrate was getting eliminated.
#'
#' @param t0 start time for compound being plotted
#' @param conc_point Concentration point to plot. Options are: \describe{
#'
#'   \item{"C0"}{concentration for the first time point available for that dose}
#'
#'   \item{"Clast"}{(default) concentration for the last time point available
#'   for that dose}
#'
#'   \item{"Cmin"}{the minimum concentration for that dosing interval, which may
#'   not be the last time point; this is somewhat prone to sampling artifacts
#'   and we generally recommend using "Clast" instead}
#'
#'   \item{"Cmax"}{the maximum concentration for that dose number}}
#' @param mark_dosing optionally mark dosing intervals on the graph as "none"
#'   (default) to have no marks for the dosing intervals or a combination of a
#'   color in R and a named linetype, e.g., "red dotted" or "blue dashed" or
#'   even "#FFBE33 longdash".
#' @param diff_cutoff what percent difference cutoff would you like to use to
#'   color the points? The default is for points with less than a 5\% difference
#'   from the previous point to be blue and points with a larger percent
#'   difference to be red.
#' @param ct_dataframe the input concentration-time data generated by running
#'   the function \code{\link{extractConcTime}} or, if you'd also like to see an
#'   overlay of the substrate with or without any inhibitors, by running
#'   \code{\link{extractConcTime_mult}}. This function assumes there's data for
#'   only one tissue and that it's appropriate to compare all the data included,
#'   so you'll get graph artifacts if those are not the case.
#' @param mean_type the mean type to use since this function only displays
#'   summary data; defaults to the arithmetic mean
#' @param accum_compoundID the compound ID to monitor for accumulation. Defaults
#'   to "inhibitor 1". The time point requested will be shown as points and will
#'   be colored by percent difference from the previous point.
#' @param overlay_compoundID the compound ID to overlay the complete
#'   concentration-time data for. Defaults to "substrate"; use "none" for no
#'   overlaid plot. This was designed for the following scenario: Monitor
#'   Ctrough for an inhibitor to make sure that it's at steady state, plot that
#'   as points, and then plot the concentration-time profile of a substrate over
#'   that to make sure that the inhibitor is present the whole time the
#'   substrate is being eliminated.
#' @param save_graph optionally save the output graph by supplying a file name
#'   in quotes here, e.g., "My conc time graph.png". If you do not designate a
#'   file extension, it will be saved as a png file, but if you specify a
#'   different file extension, it will be saved as that file format. Acceptable
#'   extensions are "eps", "ps", "jpeg", "jpg", "tiff", "png", "bmp", or "svg".
#'   Leaving this as NA means the file will not be automatically saved to disk.
#' @param fig_height figure height in inches; default is 6
#' @param fig_width figure width in inches; default is 5
#'
#' @return a ggplot2 graph 
#' @export
#'
#' @examples
#'
#' check_accumulation(ct_dataframe = MDZ_Keto)
#' 
#' check_accumulation(ct_dataframe = MDZ_Keto, conc_point = "Cmax") 
#' 
#' check_accumulation(ct_dataframe = MDZ_Keto, conc_point = "Cmax",
#'    accum_compoundID = "inhibitor 1", overlay_compoundID = "none", 
#'    mark_dosing = "pink dotted", diff_cutoff = 0.01, 
#'    save_graph = "MDZ keto accumulation check.png")
#'
#' 
check_accumulation <- function(ct_dataframe,
                               accum_compoundID = "inhibitor 1", 
                               overlay_compoundID = "substrate",
                               t0 = 0,
                               conc_point = "Clast",
                               mark_dosing = "none",
                               diff_cutoff = 0.05,
                               mean_type = "arithmetic", 
                               x_axis_interval = NA,
                               save_graph = NA,
                               fig_height = 4,
                               fig_width = 8){
    
    MyMeanType <- ct_dataframe %>%
        filter(CompoundID == accum_compoundID & 
                   Trial %in% c("geomean", "mean", "median")) %>% 
        pull(Trial) %>% unique() %>% 
        factor(levels = c("mean", "geomean", "median")) %>% 
        sort()
    
    if(switch(mean_type, "arithmetic" = "mean", "geometric" = "geomean",
              "median" = "median") %in% ct_dataframe$Trial == FALSE){
        
        warning(paste0("You requested the ", 
                       switch(mean_type, "arithmetic" = "arithmetic means",
                              "geometric" = "geometric means", 
                              "median" = "medians"), 
                       ", but those are not included in your data. Instead, the ",
                       ifelse(MyMeanType[1] == "mean", 
                              "arithmetic mean", MyMeanType[1]),
                       "s will be used."))
        MyMeanType <- MyMeanType[1] %>% as.character()
        
    } else {
        MyMeanType <- switch(mean_type, "arithmetic" = "mean", "geometric" = "geomean",
                             "median" = "median")
    }
    
    # Adjusting conc units to ng/mL. At some point, we could make this detect
    # the units and then adjust the graph titles to whatever is in the data, but
    # for now, just making everything be ng/mL for convenience.
    ct_dataframe <- match_units(ct_dataframe, list("Conc_units" = "ng/mL"))
    
    suppressMessages(
        SScheck <- ct_dataframe %>% 
            filter(Trial == MyMeanType & CompoundID == accum_compoundID) %>%  
            group_by(DoseNum, Inhibitor) %>% 
            # switch doesn't seem to work with summarize. Calculating each value.
            summarize(t0 = min(Time),
                      tlast = max(Time),
                      tmin = Time[which.min(Conc)],
                      tmax = Time[which.max(Conc)], 
                      Cmin = min(Conc), 
                      Cmax = max(Conc), 
                      C0 = Conc[which.min(Time)], 
                      Clast = Conc[which.max(Time)]) %>% 
            ungroup() %>% 
            mutate(Conc = switch(conc_point, 
                                 "Cmin" = Cmin,
                                 "Cmax" = Cmax, 
                                 "C0" = C0, 
                                 "Clast" = Clast),
                   Time = switch(conc_point, 
                                 "Cmin" = tmin, 
                                 "Cmax" = tmax,
                                 "C0" = t0, 
                                 "Clast" = tlast)) %>% 
            mutate(PercDiff = c(NA, diff(Conc, lag = 1))/Conc, 
                   DiffCriterion = abs(PercDiff) < diff_cutoff,
                   DiffCriterion = ifelse(is.na(DiffCriterion), FALSE, DiffCriterion), 
                   DiffCriterion_lab = ifelse(DiffCriterion, 
                                              paste0("<", diff_cutoff*100, "%"),
                                              paste0("\u2265", diff_cutoff*100, "%")), 
                   DiffCriterion_lab = factor(DiffCriterion_lab, 
                                              levels = c(paste0("\u2265", diff_cutoff*100, "%"),
                                                         paste0("<", diff_cutoff*100, "%"))))
    )
    
    # Setting up x axis breaks to be pretty
    PossBreaks <- data.frame(
        Tlast = c(2, 4, 8, 12, 24, 48, 96, 168, 336, 360, 504, 672, Inf),
        BreaksToUse = c("2hr", "4hr", "8hr", "12hr", "24hr", "48hr", "96hr",
                        "1wk", "2wk",
                        "15d", "3wk", "4wk", "4wkplus"))
    
    BreaksToUse <- PossBreaks %>% filter(Tlast >= max(ct_dataframe$Time)) %>%
        slice(which.min(Tlast)) %>% pull(BreaksToUse)
    
    BreaksToUse <- ifelse(complete.cases(x_axis_interval),
                          "UserDefined", BreaksToUse)
    
    XBreaks <- switch(BreaksToUse,
                      "2hr" = seq(0, 2, 0.25),
                      "4hr" = seq(0, 4, 0.5),
                      "8hr" = seq(0, 8, 0.5),
                      "12hr" = seq(0, 12, 1),
                      "24hr" = seq(0, 24, 2),
                      "48hr" = seq(0, 48, 4),
                      "96hr" = seq(0, 96, 6),
                      "1wk" = seq(0, 168, 12),
                      "2wk" = seq(0, 336, 24),
                      "15d" = seq(0, 360, 24),
                      "3wk" = seq(0, 504, 36),
                      "4wk" = seq(0, 672, 48),
                      "4wkplus" = round_up_nice(seq(0, max(ct_dataframe$Time),
                                                    length.out = 12)),
                      "UserDefined" = seq(0, max(Data$Time, na.rm = T),
                                          x_axis_interval/2))
    
    XLabels <- XBreaks
    XLabels[seq(2,length(XLabels),2)] <- ""
    XLabels[which(XBreaks == 0)] <- "0"
    
    # Noting whether effector present and what it is
    MyEffector <- unique(ct_dataframe$Inhibitor[ct_dataframe$Inhibitor != "none"])
    
    if(length(MyEffector) > 0){
        ct_dataframe <- ct_dataframe %>%
            mutate(Inhibitor = factor(Inhibitor, levels = c("none", MyEffector)))
    }
    
    # Setting up graphs
    LineAES <- str_split(mark_dosing, pattern = " ")[[1]]
    
    G <- ggplot(SScheck, aes(x = Time, y = Conc, color = DiffCriterion_lab))
    
    if(mark_dosing != "none"){
        G <- G + 
            geom_vline(xintercept = SScheck$t0, 
                       color = LineAES[1], linetype = LineAES[2])
    }
    
    G <- G +
        geom_point(size = 2) + 
        labs(color = paste(str_to_title(accum_compoundID),
                           "difference\nfrom previous point"), 
             linetype = paste(str_to_title(overlay_compoundID), "concentration")) +
        xlab("Time (h)") +
        scale_x_continuous(breaks = XBreaks, 
                           labels = XLabels) +
        scale_color_brewer(palette = "Set1") +
        theme(panel.background = element_rect(fill="white", color=NA),
              legend.key = element_rect(fill = "white"),
              axis.ticks = element_line(color = "black"),
              axis.text = element_text(color = "black"),
              axis.title = element_text(color = "black"),
              axis.line.x.bottom = element_line(color = "black"),
              axis.line.y.left = element_line(color = "black"))
    
    
    if(overlay_compoundID != "none"){
        
        OverlayCT <- ct_dataframe %>% 
            filter(Trial == MyMeanType & CompoundID == overlay_compoundID) %>% 
            mutate(Inhibitor = ifelse(Inhibitor == "none", 
                                      "without effector",
                                      paste("with", MyEffector)), 
                   Inhibitor = factor(Inhibitor, 
                                      levels = c("without effector",
                                                 paste("with", MyEffector))))
        
        # Checking for differences in scale between accum_compoundID and
        # overlay_compoundID
        ScaleChallenges <- abs(max(SScheck$Conc, na.rm = T) - 
                                   max(OverlayCT$Conc, na.rm = T))
        
        if(complete.cases(ScaleChallenges) && ScaleChallenges > 100){
            OverlayCT <- OverlayCT %>% 
                mutate(Conc = Conc * round_up(max(SScheck$Conc, na.rm = T) /
                                                  max(OverlayCT$Conc, na.rm = T)))
        } 
        
        if(length(MyEffector) > 0){
            G <- G + 
                geom_line(data = OverlayCT, 
                          aes(x = Time, y = Conc, linetype = Inhibitor), 
                          inherit.aes = F, color = "gray50") +
                scale_linetype_manual(values = c("solid", "dashed"))
        } else {
            
            G <- G + 
                geom_line(data = OverlayCT, 
                          aes(x = Time, y = Conc),
                          inherit.aes = F, color = "gray50")
        }
        
        # Adding 2nd y axis if there were big differences in scale.
        if(complete.cases(ScaleChallenges) && ScaleChallenges> 100){
            G <- G +
                scale_y_continuous(
                    paste(str_to_title(accum_compoundID), 
                          switch(conc_point, 
                                 "Cmin" = "Cmin (ng/mL)", 
                                 "Cmax" = "Cmax (ng/mL)", 
                                 "C0" = "C0 (ng/mL)",
                                 "Clast" = "Clast (ng/mL)")), 
                    sec.axis = sec_axis(~ . / round_down(ScaleChallenges),
                                        name = paste(str_to_title(overlay_compoundID),
                                                     "concentration (ng/mL)"))) +
                theme(axis.line.y.right = element_line(color = "black"))
        } else {
            
            G <- G +
                scale_y_continuous(limits = c(0, max(c(OverlayCT$Conc, 
                                                       SScheck$Conc)))) +
                ylab(switch(conc_point, 
                            "Cmin" = expression(C[min]~"(ng/mL)"), 
                            "Cmax" = expression(C[max]~"(ng/mL)"), 
                            "C0" = expression(C[0]~"(ng/mL)"),
                            "Clast" = expression(C[last]~"(ng/mL)")))
        }
        
        # Adding legend item saying that points are for accum_compoundID and
        # lines are for overlay_compoundID. 
        Empty <- data.frame(Time = mean(OverlayCT$Time),
                            Conc = as.numeric(NA), 
                            Type = c(accum_compoundID, overlay_compoundID))
        G <- G +
            geom_point(data = Empty, aes(x = Time, y = Conc, alpha = Type),
                       inherit.aes = F) +
            geom_line(data = Empty, aes(x = Time, y = Conc, alpha = Type),
                      inherit.aes = F)  +
            scale_alpha_manual(
                name = "Compound", values = c(1,1),
                breaks = c(accum_compoundID, overlay_compoundID))
        
    } else {
        G <- G + 
            scale_y_continuous(limits = c(0, max(SScheck$Conc))) +
            ylab(switch(conc_point, 
                        "Cmin" = expression(C[min]~"(ng/mL)"), 
                        "Cmax" = expression(C[max]~"(ng/mL)"), 
                        "C0" = expression(C[0]~"(ng/mL)"),
                        "Clast" = expression(C[last]~"(ng/mL)")))
        
    }
    
    # Setting order of legend items 
    G <- G + 
        guides(alpha = guide_legend(order = 1, 
                                    override.aes =
                                        list(linetype = c("blank", "solid"),
                                             shape = c(16, NA),
                                             size = c(2, 0.5),
                                             color = c("#7030A0", "gray50"))), 
               color = guide_legend(order = 2),
               linetype = guide_legend(order = 3))
    
    
    if(complete.cases(save_graph)){
        FileName <- save_graph
        if(str_detect(FileName, "\\.")){
            # Making sure they've got a good extension
            Ext <- sub("\\.", "", str_extract(FileName, "\\..*"))
            FileName <- sub(paste0(".", Ext), "", FileName)
            Ext <- ifelse(Ext %in% c("eps", "ps", "jpeg", "tiff",
                                     "png", "bmp", "svg", "jpg"), 
                          Ext, "png")
            FileName <- paste0(FileName, ".", Ext)
        } else {
            FileName <- paste0(FileName, ".png")
        }
        
        ggsave(FileName, height = fig_height, width = fig_width, dpi = 600,
               plot = G)
    }
    
    return(G)
    
}

