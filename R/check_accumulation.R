#' Create a graph of simulated concentrations to check for accumulation
#'
#' Create a graph with time on the x axis and then the concentration of a
#' compound at some useful time point point -- t0, tmax, tmin (see notes on
#' useage), or tlast for each dose -- on the y axis. Optionally overlay this
#' graph with the concentration-time data for that same compound or a different
#' one. For example, you could create a graph with points for Cmax for an
#' inhibitor and then lines showing the substrate concentration-time data
#' overlaid on top of that. This way, you can check whether the substrate is
#' dosed after the inhibitor reaches steady state, and you could also check
#' whether the inhibitor was present the entire time the substrate was getting
#' eliminated.
#'
#' @param t0 start time for compound being plotted
#' @param timepoint Time point to plot. Options are: \describe{
#'
#'   \item{"t0"}{the first time point available for that dose}
#'
#'   \item{"tlast"}{(default) the last time point available for that dose}
#'
#'   \item{"tmin"}{whenever the minimum concentration occurred for that dosing
#'   interval, which may not be the last time point}
#'
#'   \item{"tmax"}{whenever the maximum observed concentration for that dose
#'   number occurred}}
#' @param mark_dosing set how to mark dosing intervals on the graph as "none"
#'   (default) to have no marks for the dosing intervals or a combination of a
#'   named color in R and a named linetype, e.g., "red dotted" or "blue dashed".
#' @param diff_cutoff what percent difference cutoff would you like to color the
#'   points by? The default is for points with less than a 5\% difference from
#'   the previous point to be blue and points with a larger percent difference
#'   to be red.
#' @param ct_dataframe the input concentration-time data generated by running
#'   the function \code{\link{extractConcTime}} or, if you'd also like to see an
#'   overlay of the substrate with or without any inhibitors, by running
#'   \code{\link{extractConcTime_mult}}. This function assumes only one tissue
#'   is included, so you'll get graph artifacts if that's not the case.
#' @param mean_type the mean type to use since this function only displays
#'   summary data; defaults to the arithmetic mean
#' @param accum_compoundID the compound ID to monitor for accumulation. Defaults
#'   to "inhibitor 1". The time point requested will be shown as points and will
#'   be colored by percent difference from the previous point.
#' @param overlay_compoundID the compound ID to overlay the complete
#'   concentration-time data for. Defaults to "substrate"; use "none" for no
#'   overlaid plot. This was designed for the following scenario: Monitor
#'   Ctrough for an inhibitor to make sure that it's at steady state, plot that
#'   as points, and then plot the concentration-time profile of a substrate over
#'   that to make sure that the inhibitor is present the whole time you're
#'   monitoring the substrate.
#'
#' @return
#' @export
#'
#' @examples
#'
#' check_accumulation(ct_dataframe = CT)
#'
#' 
check_accumulation <- function(ct_dataframe,
                               accum_compoundID = "inhibitor 1", 
                               overlay_compoundID = "substrate",
                               t0 = 0,
                               timepoint = "tlast",
                               mark_dosing = "none",
                               diff_cutoff = 0.05,
                               mean_type = "arithmetic", 
                               x_axis_interval = NA){
    
    MyMeanType <- ct_dataframe %>%
        filter(CompoundID == accum_compoundID & 
                   Trial %in% c("geomean", "mean", "median")) %>% 
        pull(Trial) %>% unique() %>% 
        factor(levels = c("mean", "geomean", "median")) %>% 
        sort()
    
    if(switch(mean_type, "arithmetic" = "mean", "geometric" = "geomean",
              "median" = "median") %in% ct_dataframe$Trial == FALSE){
        
        warning(paste0("You requested the ", 
                       switch(mean_type, "arithmetic" = "arithmetic means",
                              "geometric" = "geometric means", 
                              "median" = "medians"), 
                       ", but those are not included in your data. Instead, the ",
                       ifelse(MyMeanType[1] == "mean", 
                              "arithmetic mean", MyMeanType[1]),
                       "s will be used."))
        MyMeanType <- MyMeanType[1] %>% as.character()
        
    } else {
        MyMeanType <- switch(mean_type, "arithmetic" = "mean", "geometric" = "geomean",
                             "median" = "median")
    }
    
    suppressMessages(
        SScheck <- ct_dataframe %>% 
            filter(Trial == MyMeanType & CompoundID == accum_compoundID) %>%  
            group_by(DoseNum, Inhibitor) %>% 
            # switch doesn't seem to work with summarize. Calculating each value.
            summarize(t0 = min(Time),
                      tlast = max(Time),
                      tmin = Time[which.min(Conc)],
                      tmax = Time[which.max(Conc)], 
                      Cmin = min(Conc), 
                      Cmax = max(Conc), 
                      C0 = Conc[which.min(Time)], 
                      Clast = Conc[which.max(Time)]) %>% 
            ungroup() %>% 
            mutate(Conc = switch(timepoint, 
                                 "tmin" = Cmin, 
                                 "tmax" = Cmax, 
                                 "t0" = C0, 
                                 "tlast" = Clast), 
                   Time = switch(timepoint, 
                                 "tmin" = tmin, 
                                 "tmax" = tmax,
                                 "t0" = t0, 
                                 "tlast" = tlast)) %>% 
            mutate(PercDiff = c(NA, diff(Conc, lag = 1))/Conc, 
                   DiffCriterion = abs(PercDiff) < diff_cutoff,
                   DiffCriterion = ifelse(is.na(DiffCriterion), FALSE, DiffCriterion), 
                   DiffCriterion_lab = ifelse(DiffCriterion, 
                                              paste0("<", diff_cutoff*100, "%"),
                                              paste0("\u2265", diff_cutoff*100, "%")))
    )
    
    # Setting up x axis breaks to be pretty
    PossBreaks <- data.frame(
        Tlast = c(2, 4, 8, 12, 24, 48, 96, 168, 336, 360, 504, 672, Inf),
        BreaksToUse = c("2hr", "4hr", "8hr", "12hr", "24hr", "48hr", "96hr",
                        "1wk", "2wk",
                        "15d", "3wk", "4wk", "4wkplus"))
    
    BreaksToUse <- PossBreaks %>% filter(Tlast >= max(ct_dataframe$Time)) %>%
        slice(which.min(Tlast)) %>% pull(BreaksToUse)
    
    BreaksToUse <- ifelse(complete.cases(x_axis_interval),
                          "UserDefined", BreaksToUse)
    
    XBreaks <- switch(BreaksToUse,
                      "2hr" = seq(0, 2, 0.25),
                      "4hr" = seq(0, 4, 0.5),
                      "8hr" = seq(0, 8, 0.5),
                      "12hr" = seq(0, 12, 1),
                      "24hr" = seq(0, 24, 2),
                      "48hr" = seq(0, 48, 4),
                      "96hr" = seq(0, 96, 6),
                      "1wk" = seq(0, 168, 12),
                      "2wk" = seq(0, 336, 24),
                      "15d" = seq(0, 360, 24),
                      "3wk" = seq(0, 504, 36),
                      "4wk" = seq(0, 672, 48),
                      "4wkplus" = round_up_nice(seq(0, max(ct_dataframe$Time),
                                                    length.out = 12)),
                      "UserDefined" = seq(0, max(Data$Time, na.rm = T),
                                          x_axis_interval/2))
    
    XLabels <- XBreaks
    XLabels[seq(2,length(XLabels),2)] <- ""
    XLabels[which(XBreaks == 0)] <- "0"
    
    # Noting whether effector present and what it is
    MyEffector <- unique(ct_dataframe$Inhibitor[ct_dataframe$Inhibitor != "none"])
    
    if(length(MyEffector) > 0){
        ct_dataframe <- ct_dataframe %>%
            mutate(Inhibitor = factor(Inhibitor, levels = c("none", MyEffector)))
    }
    
    # Setting up graphs
    LineAES <- str_split(mark_dosing, pattern = " ")[[1]]
    
    G <- ggplot(SScheck, aes(x = Time, y = Conc, color = DiffCriterion_lab))
    
    if(mark_dosing != "none"){
        G <- G + 
            geom_vline(xintercept = SScheck$t0, 
                       color = LineAES[1], linetype = LineAES[2])
    }
    
    G <- G +
        geom_point(size = 1) + 
        labs(color = paste(str_to_title(accum_compoundID),
                           "difference\nfrom previous point"), 
             linetype = paste(str_to_title(overlay_compoundID), "concentration")) +
        xlab("Time (h)") +
        scale_x_continuous(breaks = XBreaks, 
                           labels = XLabels) +
        scale_color_brewer(palette = "Set1") +
        theme(panel.background = element_rect(fill="white", color=NA),
              legend.key = element_rect(fill = "white"),
              axis.ticks = element_line(color = "black"),
              axis.text = element_text(color = "black"),
              axis.title = element_text(color = "black"),
              axis.line.x.bottom = element_line(color = "black"),
              axis.line.y.left = element_line(color = "black"))
    
    
    if(overlay_compoundID != "none"){
        
        OverlayCT <- ct_dataframe %>% 
            filter(Trial == MyMeanType & CompoundID == overlay_compoundID) %>% 
            mutate(Inhibitor = ifelse(Inhibitor == "none", 
                                      "without effector",
                                      paste("with", MyEffector)), 
                   Inhibitor = factor(Inhibitor, 
                                      levels = c("without effector",
                                                 paste("with", MyEffector))))
        
        # Checking for differences in scale between accum_compoundID and
        # overlay_compoundID
        ScaleChallenges <- abs(max(SScheck$Conc, na.rm = T) - 
                                   max(OverlayCT$Conc, na.rm = T)) 
        
        if(complete.cases(ScaleChallenges) && ScaleChallenges> 100){
            OverlayCT <- OverlayCT %>% 
                mutate(Conc = Conc * round_down(ScaleChallenges))
        } 
        
        if(length(MyEffector) > 0){
            G <- G + 
                geom_line(data = OverlayCT, 
                          aes(x = Time, y = Conc, linetype = Inhibitor), 
                          inherit.aes = F, color = "gray50") +
                scale_linetype_manual(values = c("solid", "dashed"))
        } else {
            
            G <- G + 
                geom_line(data = OverlayCT, 
                          aes(x = Time, y = Conc),
                          inherit.aes = F, color = "gray50")
        }
        
        # Adding 2nd y axis if there were big differences in scale.
        if(complete.cases(ScaleChallenges) && ScaleChallenges> 100){
            G <- G +
                scale_y_continuous(
                    paste(str_to_title(accum_compoundID), 
                          switch(timepoint, 
                                 "tmin" = "Cmin (ng/mL)", 
                                 "tmax" = "Cmax (ng/mL)", 
                                 "t0" = "C0 (ng/mL)",
                                 "tlast" = "Clast (ng/mL)")), 
                    sec.axis = sec_axis(~ . / round_down(ScaleChallenges),
                                        name = paste(str_to_title(overlay_compoundID),
                                                     "concentration (ng/mL)")))
        } else {
            
            G <- G +
                scale_y_continuous(limits = c(0, max(c(OverlayCT$Conc, 
                                                       SScheck$Conc)))) +
                ylab(switch(timepoint, 
                            "tmin" = expression(C[min]~"(ng/mL)"), 
                            "tmax" = expression(C[max]~"(ng/mL)"), 
                            "t0" = expression(C[0]~"(ng/mL)"),
                            "tlast" = expression(C[last]~"(ng/mL)")))
        }
        
        # Adding legend item saying that points are for accum_compoundID and
        # lines are for overlay_compoundID. 
        Empty <- data.frame(Time = mean(OverlayCT$Time),
                            Conc = as.numeric(NA), 
                            Type = c(accum_compoundID, overlay_compoundID))
        G <- G +
            geom_point(data = Empty, aes(x = Time, y = Conc, alpha = Type),
                       inherit.aes = F) +
            geom_line(data = Empty, aes(x = Time, y = Conc, alpha = Type),
                      inherit.aes = F)  +
            scale_alpha_manual(
                name = "Compound", values = c(1,1),
                breaks = c(accum_compoundID, overlay_compoundID),
                guide = guide_legend(override.aes =
                                         list(linetype = c("blank", "solid"),
                                              shape = c(16, NA),
                                              color = c("#7030A0", "gray50"))))
        
    } else {
        G <- G + 
            scale_y_continuous(limits = c(0, max(SScheck$Conc))) +
            ylab(switch(timepoint, 
                        "tmin" = expression(C[min]~"(ng/mL)"), 
                        "tmax" = expression(C[max]~"(ng/mL)"), 
                        "t0" = expression(C[0]~"(ng/mL)"),
                        "tlast" = expression(C[last]~"(ng/mL)")))
        
    }
    
    return(G)
    
}

